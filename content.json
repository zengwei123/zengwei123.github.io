{"meta":{"title":"zengwei","subtitle":null,"description":"曾伟 个人博客 java Android","author":"zengwei","url":"https://zengwei123.github.io"},"pages":[{"title":"关于","date":"2018-08-04T10:18:03.566Z","updated":"2018-08-04T10:18:03.566Z","comments":false,"path":"about/index.html","permalink":"https://zengwei123.github.io/about/index.html","excerpt":"","text":"敲自己喜欢的代码，过自己想要的人生 性别：男 年龄：97年12月 技能：能写java，能写前端，Android最强 爱好：看小说、听歌、打游戏、敲安卓 城市：哪都想去哪都去不了，现居湖南长沙 学历：菜鸡大专 专业：软件工程 邮箱：13085486819@163.com 那天，我做了一个发财的梦，真香！"},{"title":"分类","date":"2018-08-04T09:35:24.163Z","updated":"2018-08-04T09:35:24.163Z","comments":false,"path":"categories/index.html","permalink":"https://zengwei123.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-04T11:55:17.850Z","updated":"2018-08-04T11:55:17.850Z","comments":false,"path":"repository/index.html","permalink":"https://zengwei123.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-04T07:11:39.364Z","updated":"2018-08-04T07:11:39.364Z","comments":false,"path":"tags/index.html","permalink":"https://zengwei123.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android侧滑布局-DrawerLayout","slug":"Android侧滑布局-DrawerLayout","date":"2018-08-07T03:54:14.000Z","updated":"2018-08-07T07:20:41.621Z","comments":true,"path":"2018/08/07/Android侧滑布局-DrawerLayout/","link":"","permalink":"https://zengwei123.github.io/2018/08/07/Android侧滑布局-DrawerLayout/","excerpt":"","text":"DrawerLayout是谷歌官方推出的侧滑菜单,DrawerLayout最好为界面的根布局，否则可能会出现触摸事件被屏蔽的问题；主内容区的布局代码要放在侧滑菜单布局的前面, 因为 XML 顺序意味着按 z序（层叠顺序）排序，并且抽屉式导航栏必须位于内容顶部；侧滑菜单部分的布局必须设置layout_gravity属性，他表示侧滑菜单是在左边还是右边，而且如果不设置在的时候会报错，设置了layout_gravity=”start/left”的视图才会被认为是侧滑菜单,同时侧滑的布局必须放在最下面，不然无法响应侧滑控件的的事件，只会点击之后就关闭侧滑drawerLayout左侧菜单（或者右侧）的展开与隐藏可以被DrawerLayout.DrawerListener的实现监听我们还可以通过按钮显示侧边栏侧滑的布局可以写在fragment,这里name属性就是用来对应的Fragment的经过这几步我们就吧侧滑菜单写出来了在这里 drawer_layout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.END); 锁定右面的侧滑菜单，不能通过手势关闭或者打开，只能通过代码打开！如果DrawerLayout侧滑菜单中的控件点击事件能穿透到底部,那么可以在菜单的布局文件中设置clickable=&quot;true&quot;如果想实现QQ那种底部布局跟则动的效果就在addDrawerListener事件中的onDrawerSlide()添加下面的代码,就能跟随移动了 //mDrawerLayout为你的DrawerLayout View content = mDrawerLayout.getChildAt(0); int offset = (int) (drawerView.getWidth() * slideOffset); content.setTranslationX(offset);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Api总结（持续跟新）","slug":"Api","date":"2017-08-06T04:46:49.000Z","updated":"2018-08-06T13:08:46.648Z","comments":true,"path":"2017/08/06/Api/","link":"","permalink":"https://zengwei123.github.io/2017/08/06/Api/","excerpt":"","text":"这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取 每日一文：https://interface.meiriyiwen.com/article/today?dev=1wc：字数(word count)特定某天一文：https://interface.meiriyiwen.com/article/day?dev=1&amp;date= + 日期随机一文：https://interface.meiriyiwen.com/article/random?dev=1解析：&nbsp;&nbsp;&nbsp;&nbsp;date：日期&nbsp;&nbsp;&nbsp;&nbsp;curr：今日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;prev：昨日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;next：明日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;author：作者&nbsp;&nbsp;&nbsp;&nbsp;titile：标题&nbsp;&nbsp;&nbsp;&nbsp;digest：首段&nbsp;&nbsp;&nbsp;&nbsp;content：正文内容 金山翻译：http://fy.iciba.com/ajax.phpurl 示例：http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world拼接参数：a：固定值 fyf：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autot：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autow：查询内容 解析：&nbsp;&nbsp;&nbsp;&nbsp;status：请求成功时则取 1&nbsp;&nbsp;&nbsp;&nbsp;content：内容信息&nbsp;&nbsp;&nbsp;&nbsp;from：原文内容类型&nbsp;&nbsp;&nbsp;&nbsp;to：译文内容类型&nbsp;&nbsp;&nbsp;&nbsp;vendor：来源平台&nbsp;&nbsp;&nbsp;&nbsp;out：译文内容&nbsp;&nbsp;&nbsp;&nbsp;err_no：请求成功时取 0 必应图片：https://www.dujin.org/sys/bing/1920.php 美女图片福利：http://gank.io/api/data/福利/10/110和1可以是其他数字，自己去试区间 一言： https://v1.hitokoto.cn/c=下面中的一个a： 动画b： 漫画c： 游戏d： 小说e： 原创f： 来自网络g： 其他其他不存在参数 任意类型随机取得 解析id：本条一言的id。hitokoto：一言正文。编码方式unicode。使用utf-8。type：类型。请参考第三节参数的表格。from：一言的出处。creator：添加者。created_at：添加时间。 历史上的今天：http://www.ipip5.com/today/api.php?type=json 美图接口api:https://pixabay.com/api/docs/官网：https://pixabay.com/zh/ 新闻API：https://fenfa.shuwen.com 更多Api:https://github.com/jokermonn/-Api","categories":[{"name":"Api","slug":"Api","permalink":"https://zengwei123.github.io/categories/Api/"}],"tags":[]},{"title":"Android四大组件之Service","slug":"Android四大组件之Service","date":"2016-09-19T02:58:12.000Z","updated":"2018-08-07T03:38:39.593Z","comments":true,"path":"2016/09/19/Android四大组件之Service/","link":"","permalink":"https://zengwei123.github.io/2016/09/19/Android四大组件之Service/","excerpt":"","text":"1.Service作用： 提供需要长期在后台长期运行的服务（如复杂计算、下载等），主要是因为它没有长的生命周期、没有用户界面、在后台运行。 2.Service分类： 本地：运行在主线程，主线程终止后服务也会终止。但是能够节约资源，并且通信方便，由于在同一进程不需要IPC和AIDL，主要使用在需要依附某个进程的服务，音乐播放等。远程：运行在独立进程，常驻在后台，不受其他Activity影响但是非常消耗资源，通讯需要比较复杂，主要使用在系统级别的服务。前台：通知栏可以显示出来，用户可以看到，主要使用在需要让用户只要并进行相关操作，如音乐播放。后台：主要是用户无法看到，主要使用在不需要让用户知道的一些操作，跟新数据，同步数据等 3.生命周期 · 如果Service是第一次启动先会执行 onCreate(),onStartCommand()· 当次启动Service调用，将只执行onStartCommand()，因为此时Service已经创建了，无需执行onCreate()回调。无论多少次的启动Service，只需要一次stopService()即可将此Service终止，执行onDestroy()函数。· onStartCommand(..)可以多次被调用，onDestroy()与onCreate()相匹配，当用户强制kill掉进程时，onDestroy()是不会执行的。· startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。· 当Service需要运行在单独的进程中，AndroidManifest.xml声明时需要通过android:process指明此进程名称，当此Service需要对其他App开放时，android:exported属性值需要设置为true. 4.通讯 简单通信直接通过Intent进行传值，我们在启动一个Service的时候通过Intent的对象向Service进行传值，这种方式传递值比较不方便，性能不是很高。传值：获取值： 2．绑定服务传输数据 在Service中编写Binder的内部类，自定义方法进行数据传输。活动类：服务类： 通过使用Messenger方式（可以在不同进程间通讯）服务端：客户端 5.服务单独运行在进程 在XML文件中给Service添加process属性，有两种赋值方式，一种是[:xxxxx],一种是[com.pw.xxx.xxx] 第一种赋值是一种简写，完整的写法是[com.xxx.xxx:xxxx]这样的进程是应用的私有进程，其他应用不会跟它跑到同一个地方去。而第二种就是一种全局进程，其他的应用程序可以通过ShareUID跑进去。多进程的使用地方，可以使用在一些需要保活的地方，音乐后台播放，在退出activity后还能继续播放、加载大图、推送服务，能够在程序退出后继续的向用户推送东西。将功能独立的分开来，减少程序崩溃","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android四大组件之Activity","slug":"Android四大组件之Activity","date":"2016-09-15T01:09:23.000Z","updated":"2018-08-07T02:59:42.064Z","comments":true,"path":"2016/09/15/Android四大组件之Activity/","link":"","permalink":"https://zengwei123.github.io/2016/09/15/Android四大组件之Activity/","excerpt":"","text":"1.正常的周期 OnCreate: 生命周期的第一个方法，可以做一些初始化的操作onRestart: 表示activit正在重新启动，这一般是当activity从不可见变成可见时调用，一般是由用户行为导致OnStart:这是说明activity正在被启动，即将开始。OnResume:表示activity已经可以看见了，并且出现在前台，已经与用户进行交互了。在这里OnStart和OnResume都是出现已经可见了，但是OnStart还在后台而OnResume已经出现在了前台OnPause:表示activity正在停止，这个时候OnStop马上回被调用，在这里已经进行一些数据存储，动画显示等不耗时的操作，因为OnPause要执行完才能执行其他activity的OnResume。OnStop:表示activity即将停止，在这里可以做一些资源比较有重量的回收，但是也不能太过耗时。OnDestroy:最后一个方法，表示activity活到头了，在这里可以做一些回收工作和资源释放 OnStart和OnResume、OnPause和OnStop这两对方法没有什么实质性的不同，OnResume是可见周期的最后一个方法已经结束了，OnStart是还正在启动，OnPauses要执行完之后才能执行新activity的方法，OnStop是结束周期中简的一个 2.异常的生命周期 1、资源相关的系统配置发生改变导致activity被杀死重建竖屏时变成横屏，由于设置了不同资源图片，activity会销毁重建。他会执行onPause→onSaveInstanceState→onStop→onDestroy然后onCreate→onStart→onResumeonSaceInstanceState是在异常结束activity时才会执行的方法，他会保存当前activity的状态同时会在新创建的activity调用onRestoreInstanceState方法并且将onSaceInstanceState方法保存的bundle传递给onCreate。我们可以在onSaceInstanceState中存储一些数据，在onRestoreInstanceState或者onCreate中读取，有一点onRestoreInstanceState如果执行那么Bundle是不会为空的，但是onCreate中就不知道了 2、资源不足导致优先级低的activity被杀死优先级：前台activity 可见非前台activit（比如弹出一个对话框） 后台activit杀死activity后，就会在有内存的时候通过onSaceInstanceState 保存onRestoreInstanceState恢复可以通过设置android：configChanges=”orientation” 静止重建 3.Activity启动模式 1、存在的意义：多次启动同一个activity，多次创建同一个实例，这是很傻的行为1.standard（默认）每次启动activity都会重新创建实例2.singleTop（栈顶复用模式） 判断activity是否在任务栈顶，如果在直接引用，同时调用onNewIntent方法，如果不在就创建新的实例。3.singleTask（栈内复用模式） 判断栈中是否有这个实例，如果有那么就使用这个实例，如果没有那么就创建一个，这个activity会调用onNewIntent4.singleInstance（单实例模式）这个是 singleTask 模式的加强版，它除了具有 singleTask 模式的所有特性外，它还有一点独特的特性，那就是此模式的 Activity 只能单独地位于一个任务栈，不与其他 Activity 共存于同一个任务栈。 2、什么是任务栈：这是一个activity的参数TaskAffinity,这个参数标识了activity所需要的任务栈，默认情况下任务栈的名字为包名，我们可以给每个activity命一个名字，同名的是名字就是在一个任务栈，它主要是和singleTask或者allowTaskReparenting结合使用。在TaskAffinity和allowTaskRepaernting一起使用且allowTaskRepaernting为true的时候如果当一个应用A的activity启动了一个应用B的activity，那么这个B应用的activity会直接从A的任务栈跑到B的任务栈。当返回桌面，点击应用B，他不会启动住activity，而会显示应用A启动的acitivity 设置启动模式有两种方法：1.通过launchMode指定2.通过Intent.addFlage指定第二种的优先级比第一种要高，第二种无法指定为第四种模式 3、Activity隐式调用隐式调用能够设置一些过滤信息，如果不匹配将无法启动activity。需要匹配：action、category、dataAction：是一个字符串，这里指定匹配是字符串相同，在xml文件中如过指定了action，如果在intent中没有设置，那么是无法匹配成功的，想要匹配必须intent中的字符串与action的字符串相同。Category：Category中必须要有一个android.intent.Category.DEFAULT,而且intent可以不指定Category。Date:规则跟action一样，如果定义了那么就要指定，Date主要是一个规则，用来放置url 我们还可以在配置文件的activity中设置android:screenOrientation属性来设置他的横竖屏显示portrait（竖屏），landscape （横屏） 全屏的 Activity要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现： // 设置全屏模式 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); 4.使用 Intent 通信 在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。 在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。 如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去： Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容 bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容 bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity 那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息： Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容 bundle.getString(&quot;string_key&quot;); 上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法： Intent intent =new Intent(EX06.this,OtherActivity.class); intent.putExtra(&quot;boolean_key&quot;, true); intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;); startActivity(intent); 接收： Intent intent=getIntent(); intent.getBooleanExtra(&quot;boolean_key&quot;,false); intent.getStringExtra(&quot;string_key&quot;);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Hexo常用命令","slug":"hexo常用命令","date":"2016-09-04T08:25:04.000Z","updated":"2018-08-06T02:57:06.613Z","comments":true,"path":"2016/09/04/hexo常用命令/","link":"","permalink":"https://zengwei123.github.io/2016/09/04/hexo常用命令/","excerpt":"","text":"1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog $ hexo init [folder] 2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致 · post&nbsp;&nbsp;我一般都用post，默认就是这个 · page · draft $ hexo new [layout] 文章建立之后，在你的网站文件夹中 \\source\\_posts 路径下面可以找到创建的文章文件，是 markdown 格式的，文件后缀名为 .md, Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量,以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 · layout 布局 · title 标题 · date 建立日期 · updated 更新日期 · comments 开启文章的评论功能 · tags 标签 · categories 分类 · permalink 覆盖文章网址3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了 $ hexo g -d 4.启动本地服务,可以在写完文章后查看效果 $ hexo s 5.有时候博客写完，上传giehub无效果，那么试试清除缓存 $ hexo clean 基本的hexo编写博客的使用就到这里了，使用上面几条命令就能够创建编写上传你的文章到博客去。其他的一些操作可以去hexo官网查看官方文档HEXO官方文档","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]},{"title":"Hexo搭建博客","slug":"hexo搭建博客","date":"2016-09-02T15:15:04.000Z","updated":"2018-08-06T07:16:01.561Z","comments":true,"path":"2016/09/02/hexo搭建博客/","link":"","permalink":"https://zengwei123.github.io/2016/09/02/hexo搭建博客/","excerpt":"","text":"花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！ Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致配置不一样，我是windows所有 1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的 安装git、node.js，首先官网去下载安装包，如果是mac一行命令的事情，然后一直下一步下一步下一步就ok,没有什么其他的出问题百度吧，这里就不多说了，下面贴上两个东西的下载地址Git下找地址Node.js下找地址 2.安装Hexo 安装好Git后，桌面右击会增加两个东西 Git GUI here 、Git Bash here 这两个东西，点击Bash,就进入了Git的终端命令的界面了，你就可以快乐的敲命令了，输入 npm install -g hexo-cli刷刷刷，然后Hexo就安装好了，你就可以搭建你的博客了 3.建站 首先先创建你的网站，在git命令终端用下面这个命令 hexo init folderfolder可以自己随意命名，也可以随意指定路径，然后等待一会就把网站给你创建好了，在创建的命令信息中你可以看到自己创建的网站路径，记住这个路径，然后你可以输入hexo s这个命令启动服务来本地运行网站，浏览器输入：127.0.0.1:4000 就能够看到Hexo默认的主题我网站，这样我们就已经建好站了 4.配置到Github 首先在github上面创建一个仓库名字叫做：用户名.github.io,注意用户名一定要跟自己的github账户相同创建仓库创建好仓库之后拿到他的ssh地址或者Https地址这样我们就吧hexo对应的github仓库建立好了，然后来到博客根路径下，打开_config.yml这个文件夹找到下面这一段，将repository的内容替换成你自己刚刚拿到的ssh或HTTPs地址然后在再到下面这段，将里面的url换成你自己的：用户名.github.io(注意：这个url就是你以后博客的地址)到这里我们基本上就跟github关联起来了，但是为了以后更加方便，我们配置一下SSH 5.配置SSH 首先，终端中输入cd ~/.ssh 查看有没有SSH如果有就删除吧，然后输入ssh-keygen -t rsa -C “你的邮箱”，后面会要你输入密码，这个不用管，一直回车，最后如果出现下面这个图的样子，就是成功了然后到类似于：C:\\Users\\13085.ssh这种的目录下找到一个叫id_rsa.pub的文件，打开将里面的东西全部复制，进入GitHub到这里，SSH就全部配置完了 6.上传网站 输入命令hexo g，此时若出现如下报错：ERROR Local hexo not found in ~/blogERROR Try runing: ‘npm install hexo –save’则执行命令：npm install hexo –save若无报错，自行忽略此步骤。 然后输入hexo d,若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：npm install hexo-deployer-git –save 7.查看网站 打开浏览器输入：https://你的用户名.github.io，就能够看到你的网站了，跟前面本地看到的效果是一样的","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]}]}