{"meta":{"title":"zengwei","subtitle":null,"description":"曾伟 个人博客 java Android","author":"zengwei","url":"https://zengwei123.github.io"},"pages":[{"title":"关于","date":"2018-08-04T10:18:03.566Z","updated":"2018-08-04T10:18:03.566Z","comments":false,"path":"about/index.html","permalink":"https://zengwei123.github.io/about/index.html","excerpt":"","text":"敲自己喜欢的代码，过自己想要的人生 性别：男 年龄：97年12月 技能：能写java，能写前端，Android最强 爱好：看小说、听歌、打游戏、敲安卓 城市：哪都想去哪都去不了，现居湖南长沙 学历：菜鸡大专 专业：软件工程 邮箱：13085486819@163.com 那天，我做了一个发财的梦，真香！"},{"title":"分类","date":"2018-08-04T09:35:24.163Z","updated":"2018-08-04T09:35:24.163Z","comments":false,"path":"categories/index.html","permalink":"https://zengwei123.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2018-08-04T11:55:17.850Z","updated":"2018-08-04T11:55:17.850Z","comments":false,"path":"repository/index.html","permalink":"https://zengwei123.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-04T07:11:39.364Z","updated":"2018-08-04T07:11:39.364Z","comments":false,"path":"tags/index.html","permalink":"https://zengwei123.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Api总结（持续跟新）","slug":"Api","date":"2017-08-06T04:46:49.000Z","updated":"2018-08-06T13:08:46.648Z","comments":true,"path":"2017/08/06/Api/","link":"","permalink":"https://zengwei123.github.io/2017/08/06/Api/","excerpt":"","text":"这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取 每日一文：https://interface.meiriyiwen.com/article/today?dev=1wc：字数(word count)特定某天一文：https://interface.meiriyiwen.com/article/day?dev=1&amp;date= + 日期随机一文：https://interface.meiriyiwen.com/article/random?dev=1解析：&nbsp;&nbsp;&nbsp;&nbsp;date：日期&nbsp;&nbsp;&nbsp;&nbsp;curr：今日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;prev：昨日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;next：明日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;author：作者&nbsp;&nbsp;&nbsp;&nbsp;titile：标题&nbsp;&nbsp;&nbsp;&nbsp;digest：首段&nbsp;&nbsp;&nbsp;&nbsp;content：正文内容 金山翻译：http://fy.iciba.com/ajax.phpurl 示例：http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world拼接参数：a：固定值 fyf：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autot：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autow：查询内容 解析：&nbsp;&nbsp;&nbsp;&nbsp;status：请求成功时则取 1&nbsp;&nbsp;&nbsp;&nbsp;content：内容信息&nbsp;&nbsp;&nbsp;&nbsp;from：原文内容类型&nbsp;&nbsp;&nbsp;&nbsp;to：译文内容类型&nbsp;&nbsp;&nbsp;&nbsp;vendor：来源平台&nbsp;&nbsp;&nbsp;&nbsp;out：译文内容&nbsp;&nbsp;&nbsp;&nbsp;err_no：请求成功时取 0 必应图片：https://www.dujin.org/sys/bing/1920.php 美女图片福利：http://gank.io/api/data/福利/10/110和1可以是其他数字，自己去试区间 一言： https://v1.hitokoto.cn/c=下面中的一个a： 动画b： 漫画c： 游戏d： 小说e： 原创f： 来自网络g： 其他其他不存在参数 任意类型随机取得 解析id：本条一言的id。hitokoto：一言正文。编码方式unicode。使用utf-8。type：类型。请参考第三节参数的表格。from：一言的出处。creator：添加者。created_at：添加时间。 历史上的今天：http://www.ipip5.com/today/api.php?type=json 美图接口api:https://pixabay.com/api/docs/官网：https://pixabay.com/zh/ 新闻API：https://fenfa.shuwen.com 更多Api:https://github.com/jokermonn/-Api","categories":[{"name":"Api","slug":"Api","permalink":"https://zengwei123.github.io/categories/Api/"}],"tags":[]},{"title":"Android-事件分发机制","slug":"Android-事件分发机制","date":"2016-11-05T02:28:00.000Z","updated":"2018-08-14T07:42:12.022Z","comments":true,"path":"2016/11/05/Android-事件分发机制/","link":"","permalink":"https://zengwei123.github.io/2016/11/05/Android-事件分发机制/","excerpt":"","text":"事件分发主要分为2部分，View分发与ViewGroup，在了解事件分发的之前首先了解一下View与ViewGroup,View是没有子控件的，如Button,TextView等，但是ViewGroup是有子控件的，如ViewPager,RelativeLayout。 首先看看View的事件分发，主要是两个方法dispatchTouchEvent和OnTouchEvent，从流程是从Activity-View，Activity的dispatchTouchEvent是事件分发的第一入口。我们继承一个Button重写他的dispatchTouchEvent和OnTouchEvent调用button的setOnTouchListener和setOnClickListener重写activity的dispatchTouchEvent和OnTouchEvent点击button,我们会看到下面这个Log打印顺序 在这里你可能会奇怪为什么Activity的OnTouchEvent为什么没有调用，这是因为我们的Button在OnTouchEvent中已经处理了事件，最后执行的click，当我们将Button的OnTouchEvent返回值改为false,我们会看到下面的这中情况。这时候Activity的OnTouchEvent就被调用了，因为我们在button的OnTouchEvent不处理事件，这样最后没人处理我们只能将事件返回给Activity，这样Activity的OnTouchEvent就会被调用 这里我们看到最后没有执行click事件，并且UP也没有执行了，这是因为button在Down后没有处理事件，最后到了activity那里处理如果我们在up的时候不处理，返回一个false这样我们的Down和Up都执行但是最后的click没有执行，因为button没有处理事件，所以事件最后就到了Activity哪里，执行了OnTouchEvent最后看书： 下面来说说ViewGroup的分发事件，其实原理跟View差不多，只不过它多了一个onInterceptTouchEvent这个方法是用来控制事件是给自己消费还是分发给子控件。 1.默认的onInterceptTouchEvent总是返回false的，就是不拦截touch事件，直接分发给了子控件。所以假如我们自定义了组合控件，譬如image+文字的组合控件，并且在activity里面注册监听期待点击它的时候会产生响应，那么我们就需要重写onInterceptTouchEvent了让它返回true，将事件拦截下来。 2.如果触摸的时候，我们只想出发ontouch监听，想屏蔽onclick监听的话，就需要在ontouch里面返回true就可以了 3.android事件分发是先传递到viewgroup，然后才传递到view的 4.子view如果将传递的事件消费处理掉，viewgroup当中是接收不到任何事件的 5.简单来讲，dispatchTouchEvent方法是为了onTouch监听的，onTouchEvent是为了onClick监听的。如果ontouch监听返回false，事件会传递到onTouchEvent当中触发onClick，如果是true的话就不会继续往下传递了。","categories":[{"name":"Androidasd","slug":"Androidasd","permalink":"https://zengwei123.github.io/categories/Androidasd/"}],"tags":[]},{"title":"Android常用控件-ViewPage","slug":"Android常用控件-ViewPage","date":"2016-10-29T10:07:03.000Z","updated":"2018-08-13T11:52:00.909Z","comments":true,"path":"2016/10/29/Android常用控件-ViewPage/","link":"","permalink":"https://zengwei123.github.io/2016/10/29/Android常用控件-ViewPage/","excerpt":"","text":"ViewPage是我们非常常用的控件，他的功能就是多视图的切换 ViewPage · ViewPage他继承了ViewGroup,所以他是一个容器类，可以在其中添加其他的View。 · ViewPage需要一个Adatper来给他提供数据 · ViewPage经常与Fragment和TabLayout一起使用 使用ViewPage+TabLayout首先看看布局,这个就是一个最基本的ViewPage+TabLayout的布局了，可能TabLayout需要额外导入compile ‘com.android.support:design:26.1.0’ 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.TabLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/tabLayout&quot;&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/tabLayout&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/RelativeLayout&gt; 然后看看Fragment的代码，很简单的1234567public class MyFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view=inflater.inflate(R.layout.activity_main,null); return view; &#125;&#125; 然后编写ViewPage的适配器，注意重写getPageTitle(int position)这个方法是用来设置TabLayout的title的，因为TabLayout是跟ViewPager绑定起来的12345678910111213141516171819202122public class myViewPageAdatper extends FragmentPagerAdapter &#123; private List&lt;MyFragment&gt; myFragments; public myViewPageAdatper(FragmentManager fm, List&lt;MyFragment&gt; fragments) &#123; super(fm); this.myFragments=fragments; &#125; @Override public Fragment getItem(int position) &#123; return myFragments.get(position); &#125; @Override public int getCount() &#123; return myFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return \"标题：\"+position; &#125;&#125; 下面是ViewPage的设置最后的效果对于ViewPage我们的程序有各种各样的需求，有时候我们需要他不能够滑动这是我们可以设置setOnTouchListener()返回值为true，根据事件分发机制，在onTouch中的DOWN事件时候，将事件拦截。123456viewpager.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; return true; &#125; &#125;); 这样子是可以实现，但是如果ViewPager的Fragment里面有可以滑动的控件，比如又一个ViewPager,这样我们上面的那种办法就没有用了viewPager还是可以被拖出来，对于这种情况我们只有继承ViewPager来重新分发它的事件，禁止它的滑动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ZwViewPage extends ViewPager &#123; private boolean isScroll; public ZwViewPage(Context context) &#123; super(context); &#125; public ZwViewPage(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * 1.dispatchTouchEvent一般情况不做处理 *,如果修改了默认的返回值,子孩子都无法收到事件 */ @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; return super.dispatchTouchEvent(ev); // return true;不行 &#125; /** * 是否拦截 * 拦截:会走到自己的onTouchEvent方法里面来 * 不拦截:事件传递给子孩子 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; // return false;//可行,不拦截事件, // return true;//不行,孩子无法处理事件 //return super.onInterceptTouchEvent(ev);//不行,会有细微移动 if (isScroll)&#123; return super.onInterceptTouchEvent(ev); &#125;else&#123; return false; &#125; &#125; /** * 是否消费事件 * 消费:事件就结束 * 不消费:往父控件传 */ @Override public boolean onTouchEvent(MotionEvent ev) &#123; //return false;// 可行,不消费,传给父控件 //return true;// 可行,消费,拦截事件 //super.onTouchEvent(ev); //不行, //虽然onInterceptTouchEvent中拦截了, //但是如果viewpage里面子控件不是viewgroup,还是会调用这个方法. if (isScroll)&#123; return super.onTouchEvent(ev); &#125;else &#123; return true;// 可行,消费,拦截事件 &#125; &#125; public void setScroll(boolean scroll) &#123; isScroll = scroll; &#125;&#125; 这样子我们就实现了禁止ViewPager的滑动，下面我们来说说ViewPager的预加载。ViewPager会默认加载当前页和当前页的左右两页。一开始当前页是下标0，所以一开始默认加载第0页（指下标，下同）和第1页。当你向右滑动，当前页为第1页时，ViewPager会加载第2页，这时一共有3页存在（第0,1,2页）。再向右滑动，当前页为第2页时，会移除第0页，加载第3页，同理向左滑动当前页为第1页时，会移除第3页。我们可以设置下面的这个方法来预加载多个页面。1viewpager.setOffscreenPageLimit(int i); 但是如果我们不想要他预加呢？当每个fragment都需要去联网加载网络数据或者做一些耗时的操作，而且有其他的fragment并不是必须的，用户不一定会打开。这样的话如果还预加载的话将会浪费资源，用户体验也不好。虽然可以通过setOffscreenPageLimit(0)来设置不提前预加载，但这样的设置没有效果。通过研究ViewPager的源码，可以设置该类默认的DEFAULT_OFFSCREEN_PAGES = 0，来预防预加载。还有一直办法就是判断fragment的位置是否为当前显示ViewPager，如果是就加载，不是的话就不给加载设置ViewPager默认显示的页面,通过这个方法就可以通过代码设置页面的切换了1ViewPager.setCurrentItem(2) 如果想要下面这种效果在布局文件中色湖之ClipToPadding=“false”然后设置padding,就可以实现了","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android随笔-Fragment","slug":"Android-Fragment","date":"2016-10-18T08:09:07.000Z","updated":"2018-08-13T06:55:18.036Z","comments":true,"path":"2016/10/18/Android-Fragment/","link":"","permalink":"https://zengwei123.github.io/2016/10/18/Android-Fragment/","excerpt":"","text":"一.Fragment简介：Android在3.0中引入了Fragments的概念，主要目的是用在大屏幕设备上–例如平板电脑上，支持更加动态和灵活的UI设计。平板电脑的屏幕要比手机的大得多，有更多的空间来放更多的UI组件,并且这些组件之间会产生更多的交互。Fragment允许这样的一种设计，而不需要你亲自来管理View Hierarchy的复杂变化。通过将Activity的布局分散到Fragment中，你可以在运行时修改Activity的外观，并在由Activity管理的Back Stack中保存那些变化。 其实这只是比较官方一点的说法,其实通俗易懂点说就是,一个可以将activity拆分成几个完全独立封装的可重用的组件，每个组件有自己的生命周期和ui布局。它可以表示Activity中的行为或用户界面部分。我们可以在一个Activity中用多个Fragment组合来构建多窗格的UI，以及在多个Activity中重复使用某个Fragment。它有自己的生命周期，能接受自己的输入，并且可以在 Activity 运行时添加或删除Fragment（有点像在不同 Activity 中重复使用的“子 Activity”）。 二.Fragment生命周期： onAttach() : Fragment和Activity建立关联的时候调用，被附加到Activity中去。 onCreate() : 系统会在创建Fragment时调用此方法。可以初始化一段资源文件等等。 onCreateView() : 系统会在Fragment首次绘制其用户界面时调用此方法。要想为Fragment绘制UI，从该方法中返回的View必须是Fragment布局的根视图。如果Fragment未提供UI，您可以返回null。 onViewCreated() : 在Fragment被绘制后，调用此方法，可以初始化控件资源。 onActivityCreated() : 当onCreate onCreateView()，onViewCreated()方法执行完后调用，也就是Activity被渲染绘制出来后。 onStart() : 当系统调用该方法的时候，fragment已经显示在ui上，但还不能进行互动，因为onResume方法还没执行完。 onResume() : 该方法为fragment从创建到显示Android系统调用的最后一个生命周期方法，调用完该方法时候，fragment就可以与用户互动了。 onPause() : 系统将此方法作为用户离开Fragment的第一个信号（但并不总是意味着此Fragment会被销毁）进行调用。 通常可以在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。 onStop() : 当onStop返回的时候，fragment将从屏幕上消失。 onDestoryView() : 该方法的调用意味着在 onCreateView 中创建的视图都将被移除。 onDestroy() : Android在Fragment不再使用时会调用该方法，要注意的是这时Fragment还和Activity相关联的！并且可以获得Fragment对象，但无法对获得的Fragment进行任何操作。 onDetach() : 为Fragment生命周期中的最后一个方法，当该方法执行完后，Fragment与Activity不再有关联。 顺序如图下： 三.Fragment与Activity关系：总的来说，Fragment和Activity的生命周期类似。需要注意的是，它相比于Activity，多了onAttach(), onCreateView(), onActivityCreate)和onDestoryView()、onDetach()这几个回调函数；但是，却少了onRestart()。 onAttach(Activity) : 当Fragment和Activity发生关联时使用 onCreateView(LayoutInflater, ViewGroup, Bundle) : 创建该Fragment的视图 onActivityCreate(Bundle) : 当Activity的onCreate方法返回时调用 onDestoryView() : 与onCreateView相对应，当该Fragment的视图被移除时调用 onDetach() : 与onAttach相对应，当Fragment与Activity关联被取消时调用 关系图如下：注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现。 四.总结：在用法的代码部分参考郭神的博客，感觉郭神在代码讲解部分通俗易懂，看起来也方便。总之，在使用Fragment也有一些注意事项，不是那么完美的，虽然谷歌推荐我们用Fragment来代替Activity来使用，我们也确实这做了，现在基本主流的APP也都是少量Activity+很多Fragment，但也需要避免有些坑慎入。","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android消息机制-Handler","slug":"Android消息机制-Handler","date":"2016-10-13T06:53:50.000Z","updated":"2018-08-13T10:24:03.406Z","comments":true,"path":"2016/10/13/Android消息机制-Handler/","link":"","permalink":"https://zengwei123.github.io/2016/10/13/Android消息机制-Handler/","excerpt":"","text":"安卓中的消息机制说的其实就不同线程间的通讯，就是Handler。 为什么安卓中要有消息机制？ 因为在安卓中更新UI是必须在子线程中，UI控件部署线程安全的，如果多线程并发访问就会出现问题。 你可能要问为什么不给UI控件加上锁呢？ 这是因为上锁之后会让UI变得复杂同时效率变低，还会阻塞某些进程的执行，所以UI采用单线程模式，这对开发者也不是很麻烦，只要通过Handler就能够解决。 下面就是Handler的基本用法，在子线程中跟新UI 这个就是Handler的基本用法。 消息机制的分析 安卓的消息机制就是Handler机制，在handler机制中有两个很重要的东西，一个是Looper、另一个是MessageQueue,这两个东西和Handler凑成了Android中的非常重要的消息机制。 他的原理是这样的： 1、Handler创建一个消息，将这个消息插入到MessageQueue中。 2、Looper不断轮询MessageQueue的next方法。 3、Looper发现有消息（Message）了,就调用回调方法handlerMessage。 我们常常用Handler来进行更新UI但是这并不是说它只能够跟新UI，如同读取文件，网络请求等耗时操作都可以在Handler里面来进行的。通过上面的原理我们了解需要有一个消息队列MessageQueue，那么这个消息队列是从哪里来的呢？这里我们就要看到Looper，这个类的构造方法中创建了MessageQueue,然后将当前线程的对象保存起来。 而我们的Handler的创建也不能离开Looper,如果new一个Handler但是他没有Looper的话就会报错，可能你这里你就有疑问了，我们在上面的更新UI的实例中并没有看到哪里有Looper,这是因为我们的UI线程在创建的时候就会创建一个Looper,当我们如果在子线程new一个Handle就会出现保存，所以我们要主动去创建一个Lopper。 Lopper的几个方法 1、Looper.prepare():为当前线程创建一个Looper 2、Looper.loop():开启消息轮询 3、Looper.myLooper.quit():直接退出Looper 4、Looper.myLooper.quitSafely():设定一个标记，只有当目前已有的消息处理完才会执行退出操作。 当Looper退出之后，Handler就无法发送消息，当Looper退出后，Handler就无法发送消息，send出去的消息会返回false；当我们在子线程中创建了Looper并且所有的消息都处理完毕的时候，要记得调用quit方法，不让这个Looper就一直处于阻塞状态一直那么等待下去，同时主线程的Looper是无法退出的。 我们看看Looper的loop()方法的源码 通过代码我们知道：looper方法是一个死循环，唯一跳出的循环的方式是MessageQueue的next方法返回null，但是基本上是不可能的。如果我们不手动调用quit或者quitSafely方法的话，MessageQueue的next方法是不可能返回null的。因为当MessageQueue没有消息时，next方法会一直阻塞在那里，因为MessageQueue的next方法阻塞了，就导致Looper的loop方法也一直在阻塞了。这里我们那一分为二的谈，loop轮询不到消息：那么处于阻塞状态，然后就没有然后了，除了又轮询到了新的消息loop轮到了新的消息：Looper就会处理消息1、msg.target.dispatchMessage(msg)，这里的 msg.targe就是指Handler对象2、一圈下来，Handler发送的消息有交给了自己的dispatchMessage方法来处理了。（这个dispatchMessage方法不是Handler自己调用时，是与Handler相相关的Looper简介调用的），这样下来，就成功地将逻辑切换到指定的线程当中去了 Handler的主要工作就是接受和发送 下面是发送的方法，主要有两种post,send; 而我们接收的方法：dispatchMessage方法dispatchMessage会判断三种情况 1、如果是post发送来的message，那么就让这个message所持有的Runnable执行run方法，非常简单。Message的Callback 是一个Runnable对象，Handler的post的重载的函数不管参数多少，肯定都是有Runnable的。 private static void handleCallback(Message message) { message.callback.run(); } 2、如果是利用Handler(Callback callback) 构造函数实例化的Handler，也就是构造函数里面传入了一个CallBack的对象，那么就执行这个Callback的handlerMessage。利用这个接口和Handler的一个构造函数，我们可以这么创建Handler handler=new Handler(callback)来创建Handler;备注写明了这个接口的作用：可以创建一个Handler的实例但是不需要派生Handler的子类。对比我们日常中最经常做的，就是派生一个Handler的子类，复写handleMessage方法，而通过上面的代码，我们有了一种新的创建Handler方式，那就是不派生子类，而是通过Callback来实现。 这种方式非常少用。 看一下Handler里面的Callback这个接口的设计123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 3、如果是send方法发送的，那么就执行handleMessage，这个方法我们非常熟悉了，google的给的备注的也说了，子类必须实现方法以接受这些Message。这也就是我们最常见的最常用的方式了。 /** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) { } 参考：https://www.jianshu.com/p/9e4d1fab0f36","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android-如何在子线程中更新UI","slug":"Android如何在子线程中更新UI","date":"2016-10-07T01:27:16.000Z","updated":"2018-08-13T08:46:36.016Z","comments":true,"path":"2016/10/07/Android如何在子线程中更新UI/","link":"","permalink":"https://zengwei123.github.io/2016/10/07/Android如何在子线程中更新UI/","excerpt":"","text":"一.前言：项目开发中会涉及到一些耗时操作，这个时候就会开启一个子线程，将耗时操作放到子线程中取操作，操作完毕后，往往还要同步更新ui，这个时候如果直接在子线程中更新ui，将会导致程序的闪退，同时还会看到如下报错 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.意思是：只有创建视图层次结构的原始线程才能触及它的视图，其实说白了就是在子线程不能做更新UI的操作。 二.解决方法： 第一种方式 : runOnUiThread 第二种方式 : view.post(); 第三种方式 : Handler.post(); 第一种方式 : runOnUiThread 第二种方式 : view.post(); 第三种方式 : Handler.post();","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android侧滑布局-DrawerLayout","slug":"Android侧滑布局-DrawerLayout","date":"2016-09-26T03:54:14.000Z","updated":"2018-08-07T07:42:27.676Z","comments":true,"path":"2016/09/26/Android侧滑布局-DrawerLayout/","link":"","permalink":"https://zengwei123.github.io/2016/09/26/Android侧滑布局-DrawerLayout/","excerpt":"","text":"DrawerLayout是谷歌官方推出的侧滑菜单,DrawerLayout最好为界面的根布局，否则可能会出现触摸事件被屏蔽的问题；主内容区的布局代码要放在侧滑菜单布局的前面, 因为 XML 顺序意味着按 z序（层叠顺序）排序，并且抽屉式导航栏必须位于内容顶部；侧滑菜单部分的布局必须设置layout_gravity属性，他表示侧滑菜单是在左边还是右边，而且如果不设置在的时候会报错，设置了layout_gravity=”start/left”的视图才会被认为是侧滑菜单,同时侧滑的布局必须放在最下面，不然无法响应侧滑控件的的事件，只会点击之后就关闭侧滑drawerLayout左侧菜单（或者右侧）的展开与隐藏可以被DrawerLayout.DrawerListener的实现监听我们还可以通过按钮显示侧边栏侧滑的布局可以写在fragment,这里name属性就是用来对应的Fragment的经过这几步我们就吧侧滑菜单写出来了在这里 drawer_layout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.END); 锁定右面的侧滑菜单，不能通过手势关闭或者打开，只能通过代码打开！如果DrawerLayout侧滑菜单中的控件点击事件能穿透到底部,那么可以在菜单的布局文件中设置clickable=&quot;true&quot;如果想实现QQ那种底部布局跟则动的效果就在addDrawerListener事件中的onDrawerSlide()添加下面的代码,就能跟随移动了 //mDrawerLayout为你的DrawerLayout View content = mDrawerLayout.getChildAt(0); int offset = (int) (drawerView.getWidth() * slideOffset); content.setTranslationX(offset);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android四大组件之Service","slug":"Android四大组件之Service","date":"2016-09-19T02:58:12.000Z","updated":"2018-08-07T03:38:39.593Z","comments":true,"path":"2016/09/19/Android四大组件之Service/","link":"","permalink":"https://zengwei123.github.io/2016/09/19/Android四大组件之Service/","excerpt":"","text":"1.Service作用： 提供需要长期在后台长期运行的服务（如复杂计算、下载等），主要是因为它没有长的生命周期、没有用户界面、在后台运行。 2.Service分类： 本地：运行在主线程，主线程终止后服务也会终止。但是能够节约资源，并且通信方便，由于在同一进程不需要IPC和AIDL，主要使用在需要依附某个进程的服务，音乐播放等。远程：运行在独立进程，常驻在后台，不受其他Activity影响但是非常消耗资源，通讯需要比较复杂，主要使用在系统级别的服务。前台：通知栏可以显示出来，用户可以看到，主要使用在需要让用户只要并进行相关操作，如音乐播放。后台：主要是用户无法看到，主要使用在不需要让用户知道的一些操作，跟新数据，同步数据等 3.生命周期 · 如果Service是第一次启动先会执行 onCreate(),onStartCommand()· 当次启动Service调用，将只执行onStartCommand()，因为此时Service已经创建了，无需执行onCreate()回调。无论多少次的启动Service，只需要一次stopService()即可将此Service终止，执行onDestroy()函数。· onStartCommand(..)可以多次被调用，onDestroy()与onCreate()相匹配，当用户强制kill掉进程时，onDestroy()是不会执行的。· startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。· 当Service需要运行在单独的进程中，AndroidManifest.xml声明时需要通过android:process指明此进程名称，当此Service需要对其他App开放时，android:exported属性值需要设置为true. 4.通讯 简单通信直接通过Intent进行传值，我们在启动一个Service的时候通过Intent的对象向Service进行传值，这种方式传递值比较不方便，性能不是很高。传值：获取值： 2．绑定服务传输数据 在Service中编写Binder的内部类，自定义方法进行数据传输。活动类：服务类： 通过使用Messenger方式（可以在不同进程间通讯）服务端：客户端 5.服务单独运行在进程 在XML文件中给Service添加process属性，有两种赋值方式，一种是[:xxxxx],一种是[com.pw.xxx.xxx] 第一种赋值是一种简写，完整的写法是[com.xxx.xxx:xxxx]这样的进程是应用的私有进程，其他应用不会跟它跑到同一个地方去。而第二种就是一种全局进程，其他的应用程序可以通过ShareUID跑进去。多进程的使用地方，可以使用在一些需要保活的地方，音乐后台播放，在退出activity后还能继续播放、加载大图、推送服务，能够在程序退出后继续的向用户推送东西。将功能独立的分开来，减少程序崩溃","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android四大组件之Activity","slug":"Android四大组件之Activity","date":"2016-09-15T01:09:23.000Z","updated":"2018-08-07T02:59:42.064Z","comments":true,"path":"2016/09/15/Android四大组件之Activity/","link":"","permalink":"https://zengwei123.github.io/2016/09/15/Android四大组件之Activity/","excerpt":"","text":"1.正常的周期 OnCreate: 生命周期的第一个方法，可以做一些初始化的操作onRestart: 表示activit正在重新启动，这一般是当activity从不可见变成可见时调用，一般是由用户行为导致OnStart:这是说明activity正在被启动，即将开始。OnResume:表示activity已经可以看见了，并且出现在前台，已经与用户进行交互了。在这里OnStart和OnResume都是出现已经可见了，但是OnStart还在后台而OnResume已经出现在了前台OnPause:表示activity正在停止，这个时候OnStop马上回被调用，在这里已经进行一些数据存储，动画显示等不耗时的操作，因为OnPause要执行完才能执行其他activity的OnResume。OnStop:表示activity即将停止，在这里可以做一些资源比较有重量的回收，但是也不能太过耗时。OnDestroy:最后一个方法，表示activity活到头了，在这里可以做一些回收工作和资源释放 OnStart和OnResume、OnPause和OnStop这两对方法没有什么实质性的不同，OnResume是可见周期的最后一个方法已经结束了，OnStart是还正在启动，OnPauses要执行完之后才能执行新activity的方法，OnStop是结束周期中简的一个 2.异常的生命周期 1、资源相关的系统配置发生改变导致activity被杀死重建竖屏时变成横屏，由于设置了不同资源图片，activity会销毁重建。他会执行onPause→onSaveInstanceState→onStop→onDestroy然后onCreate→onStart→onResumeonSaceInstanceState是在异常结束activity时才会执行的方法，他会保存当前activity的状态同时会在新创建的activity调用onRestoreInstanceState方法并且将onSaceInstanceState方法保存的bundle传递给onCreate。我们可以在onSaceInstanceState中存储一些数据，在onRestoreInstanceState或者onCreate中读取，有一点onRestoreInstanceState如果执行那么Bundle是不会为空的，但是onCreate中就不知道了 2、资源不足导致优先级低的activity被杀死优先级：前台activity 可见非前台activit（比如弹出一个对话框） 后台activit杀死activity后，就会在有内存的时候通过onSaceInstanceState 保存onRestoreInstanceState恢复可以通过设置android：configChanges=”orientation” 静止重建 3.Activity启动模式 1、存在的意义：多次启动同一个activity，多次创建同一个实例，这是很傻的行为1.standard（默认）每次启动activity都会重新创建实例2.singleTop（栈顶复用模式） 判断activity是否在任务栈顶，如果在直接引用，同时调用onNewIntent方法，如果不在就创建新的实例。3.singleTask（栈内复用模式） 判断栈中是否有这个实例，如果有那么就使用这个实例，如果没有那么就创建一个，这个activity会调用onNewIntent4.singleInstance（单实例模式）这个是 singleTask 模式的加强版，它除了具有 singleTask 模式的所有特性外，它还有一点独特的特性，那就是此模式的 Activity 只能单独地位于一个任务栈，不与其他 Activity 共存于同一个任务栈。 2、什么是任务栈：这是一个activity的参数TaskAffinity,这个参数标识了activity所需要的任务栈，默认情况下任务栈的名字为包名，我们可以给每个activity命一个名字，同名的是名字就是在一个任务栈，它主要是和singleTask或者allowTaskReparenting结合使用。在TaskAffinity和allowTaskRepaernting一起使用且allowTaskRepaernting为true的时候如果当一个应用A的activity启动了一个应用B的activity，那么这个B应用的activity会直接从A的任务栈跑到B的任务栈。当返回桌面，点击应用B，他不会启动住activity，而会显示应用A启动的acitivity 设置启动模式有两种方法：1.通过launchMode指定2.通过Intent.addFlage指定第二种的优先级比第一种要高，第二种无法指定为第四种模式 3、Activity隐式调用隐式调用能够设置一些过滤信息，如果不匹配将无法启动activity。需要匹配：action、category、dataAction：是一个字符串，这里指定匹配是字符串相同，在xml文件中如过指定了action，如果在intent中没有设置，那么是无法匹配成功的，想要匹配必须intent中的字符串与action的字符串相同。Category：Category中必须要有一个android.intent.Category.DEFAULT,而且intent可以不指定Category。Date:规则跟action一样，如果定义了那么就要指定，Date主要是一个规则，用来放置url 我们还可以在配置文件的activity中设置android:screenOrientation属性来设置他的横竖屏显示portrait（竖屏），landscape （横屏） 全屏的 Activity要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现： // 设置全屏模式 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); 4.使用 Intent 通信 在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。 在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。 如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去： Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容 bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容 bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity 那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息： Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容 bundle.getString(&quot;string_key&quot;); 上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法： Intent intent =new Intent(EX06.this,OtherActivity.class); intent.putExtra(&quot;boolean_key&quot;, true); intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;); startActivity(intent); 接收： Intent intent=getIntent(); intent.getBooleanExtra(&quot;boolean_key&quot;,false); intent.getStringExtra(&quot;string_key&quot;);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Hexo常用命令","slug":"hexo常用命令","date":"2016-09-04T08:25:04.000Z","updated":"2018-08-06T02:57:06.613Z","comments":true,"path":"2016/09/04/hexo常用命令/","link":"","permalink":"https://zengwei123.github.io/2016/09/04/hexo常用命令/","excerpt":"","text":"1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog $ hexo init [folder] 2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致 · post&nbsp;&nbsp;我一般都用post，默认就是这个 · page · draft $ hexo new [layout] 文章建立之后，在你的网站文件夹中 \\source\\_posts 路径下面可以找到创建的文章文件，是 markdown 格式的，文件后缀名为 .md, Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量,以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 · layout 布局 · title 标题 · date 建立日期 · updated 更新日期 · comments 开启文章的评论功能 · tags 标签 · categories 分类 · permalink 覆盖文章网址3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了 $ hexo g -d 4.启动本地服务,可以在写完文章后查看效果 $ hexo s 5.有时候博客写完，上传giehub无效果，那么试试清除缓存 $ hexo clean 基本的hexo编写博客的使用就到这里了，使用上面几条命令就能够创建编写上传你的文章到博客去。其他的一些操作可以去hexo官网查看官方文档HEXO官方文档","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]},{"title":"Hexo搭建博客","slug":"hexo搭建博客","date":"2016-09-02T15:15:04.000Z","updated":"2018-08-06T07:16:01.561Z","comments":true,"path":"2016/09/02/hexo搭建博客/","link":"","permalink":"https://zengwei123.github.io/2016/09/02/hexo搭建博客/","excerpt":"","text":"花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！ Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致配置不一样，我是windows所有 1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的 安装git、node.js，首先官网去下载安装包，如果是mac一行命令的事情，然后一直下一步下一步下一步就ok,没有什么其他的出问题百度吧，这里就不多说了，下面贴上两个东西的下载地址Git下找地址Node.js下找地址 2.安装Hexo 安装好Git后，桌面右击会增加两个东西 Git GUI here 、Git Bash here 这两个东西，点击Bash,就进入了Git的终端命令的界面了，你就可以快乐的敲命令了，输入 npm install -g hexo-cli刷刷刷，然后Hexo就安装好了，你就可以搭建你的博客了 3.建站 首先先创建你的网站，在git命令终端用下面这个命令 hexo init folderfolder可以自己随意命名，也可以随意指定路径，然后等待一会就把网站给你创建好了，在创建的命令信息中你可以看到自己创建的网站路径，记住这个路径，然后你可以输入hexo s这个命令启动服务来本地运行网站，浏览器输入：127.0.0.1:4000 就能够看到Hexo默认的主题我网站，这样我们就已经建好站了 4.配置到Github 首先在github上面创建一个仓库名字叫做：用户名.github.io,注意用户名一定要跟自己的github账户相同创建仓库创建好仓库之后拿到他的ssh地址或者Https地址这样我们就吧hexo对应的github仓库建立好了，然后来到博客根路径下，打开_config.yml这个文件夹找到下面这一段，将repository的内容替换成你自己刚刚拿到的ssh或HTTPs地址然后在再到下面这段，将里面的url换成你自己的：用户名.github.io(注意：这个url就是你以后博客的地址)到这里我们基本上就跟github关联起来了，但是为了以后更加方便，我们配置一下SSH 5.配置SSH 首先，终端中输入cd ~/.ssh 查看有没有SSH如果有就删除吧，然后输入ssh-keygen -t rsa -C “你的邮箱”，后面会要你输入密码，这个不用管，一直回车，最后如果出现下面这个图的样子，就是成功了然后到类似于：C:\\Users\\13085.ssh这种的目录下找到一个叫id_rsa.pub的文件，打开将里面的东西全部复制，进入GitHub到这里，SSH就全部配置完了 6.上传网站 输入命令hexo g，此时若出现如下报错：ERROR Local hexo not found in ~/blogERROR Try runing: ‘npm install hexo –save’则执行命令：npm install hexo –save若无报错，自行忽略此步骤。 然后输入hexo d,若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：npm install hexo-deployer-git –save 7.查看网站 打开浏览器输入：https://你的用户名.github.io，就能够看到你的网站了，跟前面本地看到的效果是一样的","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]}]}