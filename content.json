{"meta":{"title":"zengwei","subtitle":null,"description":"曾伟 个人博客 java Android","author":"zengwei","url":"https://zengwei123.github.io"},"pages":[{"title":"","date":"2018-10-29T08:42:52.215Z","updated":"2018-10-29T08:39:16.000Z","comments":true,"path":"Ping/pdd2.html","permalink":"https://zengwei123.github.io/Ping/pdd2.html","excerpt":"","text":"拼多多 爱上奢华 新定制GG女包奢侈品女包邮差酒神包链条单肩斜挎购国际名牌真皮包 ￥899/件 购买数量 微信支付 (推荐) 由全程保障 实付款:￥899免运费 立即支付 爱上奢华 暂无优惠券 当前没有可用的优惠券～ 请在 00:00.0 内支付 微信支付 (推荐) 支付宝(支持蚂蚁花呗支付) 继续支付￥909 window.isUseHttps = true; window.rawData = { \"uid\": \"4084061946106\", \"isAbTestAfterPayError\": false, \"isGroupFullJoinOther\": false, \"isAbTestShipFreeRec\": true, \"serverTime\": 1539099975, \"frontEnv\": 1, \"frontVersion\": 2, \"isApp\": 0, \"isShowAddressCantReceiveVersion\": true, \"goodsId\": \"2683925796\", \"groupId\": 4029817323, \"skuId\": \"56146465002\", \"type\": 0, \"actionDisable\": false, \"userActionDisable\": false, \"validStatus\": null, \"isPay\": false, \"queryMallCoupon\": false, \"queryPlatformCoupon\": false, \"orderServicePath\": \"order\", \"isServerRendered\": true, \"isFinishInitLoading\": true, \"accessToken\": \"QQJ6IBHIFLBF4ZPUDMFTCWIQCMTLA4CXGLXU2274TIDUDHXYBRAA100fa3a\", \"errorRedirectUrl\": \"index.html\", \"goodsNumber\": 1, \"addressId\": \"\", \"groupOrderId\": \"\", \"orderAmount\": 80900, \"isCapitalOwner\": false, \"duoduoType\": 0, \"hasDownloadApp\": false, \"showFreeCoupon\": false, \"showEditAddress\": false, \"showIdCard\": false, \"showGreenShieldPopUp\": false, \"showIdCardHint\": false, \"orderRemarkText\": \"\", \"priceInfo\": {\"orderPrice\": 80900, \"mallPromotionPrice\": 0, \"platformPromotionPrice\": 0}, \"idCardInfo\": {\"idCardName\": \"\", \"idCardNo\": \"\"}, \"btnStatus\": 0, \"goodsInfo\": { \"number\": 1, \"price\": 0, \"name\": \"\\u65B0\\u5B9A\\u5236GG\\u5973\\u5305\\u5962\\u4F88\\u54C1\\u5973\\u5305\\u90AE\\u5DEE\\u9152\\u795E\\u5305\\u94FE\\u6761\\u5355\\u80A9\\u659C\\u630E\\u8D2D\\u56FD\\u9645\\u540D\\u724C\\u771F\\u76AE\\u5305\", \"allowedRegion\": \"2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32\", \"costProvinceCodes\": \"5,9,19,20,21,28,29\", \"isCustoms\": false, \"goodsType\": 1, \"eventType\": 0, \"mallId\": 895953103, \"costTemplateId\": 5759414, \"catId\": 8566, \"catId1\": 8538, \"catId2\": 8544, \"catId3\": 8566, \"catId4\": 0, \"realNameAuth\": 0, \"goodsNumber\": 1, \"isInstallment\": 0, \"goodsLabels\": [], \"groupId\": 4029817323, \"customerNum\": 2, \"buyLimit\": 999999, \"startTime\": 1451577600, \"thumbUrl\": \"http://t00img.yangkeduo.com/goods/images/2018-08-29/13cf6027faf5561122c19e5185c7f070.jpeg\", \"specs\": [], \"specifications\": [], \"skuId\": 56146465002, \"normalPrice\": \"940\", \"groupPrice\": \"809\", \"weight\": 0, \"wareId\": \"0\", \"activityId\": \"4937435\", \"unitPriceForCent\": 80900, \"unitPrice\": \"809\", \"needId\": false, \"quantity\": 2288, \"limitQuantity\": 105, \"isSpikeGoods\": false, \"isCapitalGift\": false, \"isCapitalGiftLottery\": false, \"isCompensationGoods\": false, \"isDepositeGoods\": false, \"isFreeTrial\": false, \"isMultiplyGoodsDiscount\": false, \"isThreeForTwo\": false, \"isMTBZ\": false, \"isSuccessiveMobileFee\": false, \"isVirtualGoods\": false, \"isMobile\": false, \"isGasNumber\": false, \"isQQNumber\": false, \"needAccount\": false, \"accountBits\": null }, \"mallInfo\": { \"name\": \"\\u7231\\u4E0A\\u5962\\u534E\", \"logo\": \"http://t00img.yangkeduo.com/chat/images/2018-08-18/92308e14ce42c054a619fc4fac42142f.png\", \"id\": 895953103, \"canCompensate\": false }, \"installmentList\": [], \"payMethods\": [], \"payChannelList\": [{ \"rank\": 1, \"payContent\": \"\\u5FAE\\u4FE1\\u652F\\u4ED8\", \"paySubContent\": \" (\\u63A8\\u8350)\", \"appId\": 2, \"display\": true, \"enable\": true, \"recommend\": true, \"selected\": false }, { \"rank\": 2, \"payContent\": \"\\u5FAE\\u4FE1\\u652F\\u4ED8\", \"paySubContent\": \" (\\u63A8\\u8350)\", \"appId\": 38, \"display\": true, \"enable\": true, \"recommend\": true, \"selected\": false }, { \"rank\": 3, \"payContent\": \"\\u652F\\u4ED8\\u5B9D\", \"paySubContent\": \"\", \"appId\": 35, \"display\": true, \"enable\": true, \"recommend\": false, \"selected\": false }, { \"rank\": 4, \"payContent\": \"\\u652F\\u4ED8\\u5B9D\", \"paySubContent\": \"\", \"appId\": 9, \"display\": true, \"enable\": true, \"recommend\": false, \"selected\": false }], \"addressInfo\": { \"addressId\": 0, \"name\": \"\", \"province\": \"\", \"city\": \"\", \"district\": \"\", \"address\": \"\", \"mobile\": \"\", \"provinceId\": \"\", \"isGoodsSoldHere\": false, \"addressLabel\": null }, \"shippingInfo\": {\"title\": \"\", \"cost\": 0, \"shippingPrice\": \"0\"}, \"promotionInfo\": { \"captainCoupon\": null, \"mallCoupon\": { \"batchId\": null, \"couponId\": null, \"promotionStatus\": 0, \"discount\": null, \"displayType\": null, \"displayName\": null, \"isReachMinAmount\": null, \"minAmount\": null, \"notUse\": null, \"eventDiscount\": null, \"eventId\": null, \"promotionEventType\": null }, \"platformCoupon\": { \"batchId\": null, \"couponId\": null, \"promotionStatus\": 0, \"discount\": null, \"displayType\": null, \"displayName\": null, \"isReachMinAmount\": null, \"minAmount\": null, \"notUse\": null, \"isSuperpositionCoupon\": null, \"superpositionCouponNumber\": 0, \"isPlatformCouponForbidden\": false } }, \"paymentType\": 0, \"termIndex\": 0, \"receivingMallCouponList\": [], \"mallCouponList\": {\"enableCoupons\": [], \"disableCoupons\": []}, \"platformCouponList\": {\"enableCoupons\": [], \"disableCoupons\": []}, \"repeatedCoupon\": {}, \"promotionEvent\": null, \"orderSn\": null, \"showMorePlatformCoupon\": false, \"showNoMoreHint\": false, \"showRepayModifyPanel\": false, \"usePriority\": 0, \"activityParams\": {\"duoduo_type\": 0, \"biz_type\": 0, \"pid\": \"\", \"cps_sign\": \"\", \"out_group_order_id\": \"\"}, \"pageFrom\": 0, \"isWeChatPlatform\": false, \"appIdSet\": {\"2\": 6, \"9\": 1, \"30\": 3, \"31\": 4, \"35\": 5, \"38\": 2, \"52\": 7}, \"promotionEventInfo\": null }; .pin-spinner-2 { display: none; position: fixed; width: .66rem; height: .66rem; top: 35%; margin: 0 auto; left: 0; right: 0; z-index: 999999999; } .ps-inner-box { width: 100%; height: 100%; } .ps-rotate-img { width: .25rem; height: .25rem; margin: auto; left: 0; right: 0; top: 0; bottom: 0; animation: rotateImg 2.5s linear infinite; -webkit-animation: rotateImg 2.5s linear infinite; z-index: 9999999999; position: absolute; } .ps-rotate-msg { width: 100%; font-size: .15rem; text-align: center; color: #fff; position: relative; bottom: 0px; display: none; } .ps-background { display: none; position: absolute; width: 100%; height: 100%; opacity: 0.7; background-color: #000; border-radius: .09rem; } .pin-spinner-2 { display: block; top: 50%; margin-top: -.66rem; width: .66rem; height: .66rem; } .pin-spinner-2.hasMessageText { margin-top: -.82rem; width: 1rem; height: 1rem; } .hasMessageText .ps-rotate-img { bottom: .43rem; top: .18rem; width: .36rem; height: .36rem; } .hasMessageText .ps-rotate-msg { display: block; bottom: .32rem; } @keyframes rotateImg { 0% { transform: rotateZ(0deg); } 50% { transform: rotateZ(180deg); } 100% { transform: rotateZ(360deg); } } @-webkit-keyframes rotateImg { 0% { -webkit-transform: rotateZ(0deg); } 50% { -webkit-transform: rotateZ(180deg); } 100% { -webkit-transform: rotateZ(360deg); } } @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) { .pin-spinner-2 { margin-top: -.82rem; } } 雨后彩虹正在看这个商品 窗口尺寸: 412 x 660视窗尺寸: 412 x 660"},{"title":"","date":"2018-10-29T08:42:52.246Z","updated":"2018-10-29T08:39:42.000Z","comments":true,"path":"Ping/pdd3.html","permalink":"https://zengwei123.github.io/Ping/pdd3.html","excerpt":"","text":"微信安全支付 微信支付 ￥899.00 商家 拼多多网上商城 购买物品 新定制GG女包奢侈品女包邮差酒神包链条单肩斜挎购国际名牌真皮包 商户订单号 11938-2018101936676 请使用微信扫一扫 扫描二维码完成支付 手机用户可保存上方二维码到手机中 在微信扫一扫中选择“相册”即可 // 订单详情 $('#orderDetail .arrow').click(function (event) { if ($('#orderDetail').hasClass('detail-open')) { $('#orderDetail .detail-ct').slideUp(500, function () { $('#orderDetail').removeClass('detail-open'); }); } else { $('#orderDetail .detail-ct').slideDown(500, function () { $('#orderDetail').addClass('detail-open'); }); } });"},{"title":"分类","date":"2018-08-04T09:35:24.163Z","updated":"2018-08-04T09:35:24.163Z","comments":false,"path":"categories/index.html","permalink":"https://zengwei123.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-08-04T10:18:03.566Z","updated":"2018-08-04T10:18:03.566Z","comments":false,"path":"about/index.html","permalink":"https://zengwei123.github.io/about/index.html","excerpt":"","text":"敲自己喜欢的代码，过自己想要的人生 性别：男 年龄：97年12月 技能：能写java，能写前端，Android最强 爱好：看小说、听歌、打游戏、敲安卓 城市：哪都想去哪都去不了，现居湖南长沙 学历：菜鸡大专 专业：软件工程 邮箱：13085486819@163.com 那天，我做了一个发财的梦，真香！"},{"title":"","date":"2018-09-25T06:49:49.312Z","updated":"2018-09-25T06:49:49.312Z","comments":true,"path":"my/index.html","permalink":"https://zengwei123.github.io/my/index.html","excerpt":"","text":"成绩查询 - 中国教育考试网 #Body{ margin: auto; min-width: 1200px; max-width: 1200px; text-align: center; } a{ color: #003E7D; } a:hover{ color: #FF7F00; } a:link { text-decoration: none; } 关于我们 | ENGLISH 首页 考试资讯 公示公告 考试项目 考试报名 成绩查询 证书查询 考试研究 高考问卷调查 首页>成绩查询 2018全国法律职业资格考试成绩查询 准考证号： 姓名： 证件号： 8+8验证码： document.getElementById(\"Content1\").style.height=document.documentElement.clientHeight-297+\"px\"; var a=Math.round(Math.random()*10); var b=Math.round(Math.random()*10); document.getElementById(\"ab\").innerHTML=a+\"+\"+b; function f() { var s1=document.getElementById(\"s1\").value; var s2=document.getElementById(\"s2\").value; var s3=document.getElementById(\"s3\").value; var s4=document.getElementById(\"s4\").value; if(s4==(a+b)){ if(s1==\"1870645723963\"&&s2==\"李邱思君\"&&s3==\"432503199501154016\"){ window.location.replace(\"query.html\") }else{ alert(\"查询为空\"); } }else{ location.reload(); } }"},{"title":"","date":"2018-09-25T03:31:24.769Z","updated":"2018-09-25T03:31:24.769Z","comments":true,"path":"my/query.html","permalink":"https://zengwei123.github.io/my/query.html","excerpt":"","text":"2018国家法律职业资格考试 2018湖南省国家法考办公室 成绩通知单 姓&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名：李邱思君 证件号码：432503199501154016 准考证号：1870645723963 试卷一 试卷二 总分 84 85 169 注意事项： 1.&nbsp;&nbsp;&nbsp;本成绩通知书由本人自行下载打印，黑白即可，并保存备用。 2.&nbsp;&nbsp;&nbsp;应试人员如对成绩有异议，可以在考试成绩公布之日起 15日内向报名地司法行政机关提出核查分数的书面申请。 3.&nbsp;&nbsp;&nbsp;本成绩通知书是申请授予法律资格证书的有效证件，请予妥善保管。"},{"title":"项目","date":"2018-08-04T11:55:17.850Z","updated":"2018-08-04T11:55:17.850Z","comments":false,"path":"repository/index.html","permalink":"https://zengwei123.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-04T07:11:39.364Z","updated":"2018-08-04T07:11:39.364Z","comments":false,"path":"tags/index.html","permalink":"https://zengwei123.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-29T08:42:52.199Z","updated":"2018-10-29T08:39:16.000Z","comments":true,"path":"Ping/pdd1.html","permalink":"https://zengwei123.github.io/Ping/pdd1.html","excerpt":"","text":"拼多多 限时领888元新人红包，点击拆开 1 / 10"}],"posts":[{"title":"Api总结（持续跟新）","slug":"Api","date":"2017-08-06T04:46:49.000Z","updated":"2018-08-06T13:08:46.648Z","comments":true,"path":"2017/08/06/Api/","link":"","permalink":"https://zengwei123.github.io/2017/08/06/Api/","excerpt":"","text":"这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取 每日一文：https://interface.meiriyiwen.com/article/today?dev=1wc：字数(word count)特定某天一文：https://interface.meiriyiwen.com/article/day?dev=1&amp;date= + 日期随机一文：https://interface.meiriyiwen.com/article/random?dev=1解析：&nbsp;&nbsp;&nbsp;&nbsp;date：日期&nbsp;&nbsp;&nbsp;&nbsp;curr：今日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;prev：昨日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;next：明日日期，yyyyMMdd 格式&nbsp;&nbsp;&nbsp;&nbsp;author：作者&nbsp;&nbsp;&nbsp;&nbsp;titile：标题&nbsp;&nbsp;&nbsp;&nbsp;digest：首段&nbsp;&nbsp;&nbsp;&nbsp;content：正文内容 金山翻译：http://fy.iciba.com/ajax.phpurl 示例：http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world拼接参数：a：固定值 fyf：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autot：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 autow：查询内容 解析：&nbsp;&nbsp;&nbsp;&nbsp;status：请求成功时则取 1&nbsp;&nbsp;&nbsp;&nbsp;content：内容信息&nbsp;&nbsp;&nbsp;&nbsp;from：原文内容类型&nbsp;&nbsp;&nbsp;&nbsp;to：译文内容类型&nbsp;&nbsp;&nbsp;&nbsp;vendor：来源平台&nbsp;&nbsp;&nbsp;&nbsp;out：译文内容&nbsp;&nbsp;&nbsp;&nbsp;err_no：请求成功时取 0 必应图片：https://www.dujin.org/sys/bing/1920.php 美女图片福利：http://gank.io/api/data/福利/10/110和1可以是其他数字，自己去试区间 一言： https://v1.hitokoto.cn/c=下面中的一个a： 动画b： 漫画c： 游戏d： 小说e： 原创f： 来自网络g： 其他其他不存在参数 任意类型随机取得 解析id：本条一言的id。hitokoto：一言正文。编码方式unicode。使用utf-8。type：类型。请参考第三节参数的表格。from：一言的出处。creator：添加者。created_at：添加时间。 历史上的今天：http://www.ipip5.com/today/api.php?type=json 美图接口api:https://pixabay.com/api/docs/官网：https://pixabay.com/zh/ 新闻API：https://fenfa.shuwen.com 更多Api:https://github.com/jokermonn/-Api","categories":[{"name":"Api","slug":"Api","permalink":"https://zengwei123.github.io/categories/Api/"}],"tags":[]},{"title":"js选择和java图片水印清除","slug":"记录-js选择和java图片水印清除","date":"2017-03-01T08:22:44.000Z","updated":"2018-10-15T08:26:38.809Z","comments":true,"path":"2017/03/01/记录-js选择和java图片水印清除/","link":"","permalink":"https://zengwei123.github.io/2017/03/01/记录-js选择和java图片水印清除/","excerpt":"","text":"实现网页选中效果,能够选择div中的内容 1234567891011121314151617selectText(&apos;填入id&apos;);function selectText(element) &#123; var text = document.getElementById(element); if (document.body.createTextRange) &#123; var range = document.body.createTextRange(); range.moveToElementText(text); range.select(); &#125; else if (window.getSelection) &#123; var selection = window.getSelection(); var range = document.createRange(); range.selectNodeContents(text); selection.removeAllRanges(); selection.addRange(range); &#125; else &#123; alert(&quot;none&quot;); &#125; &#125; 找到一个去除水印的东西记录一下，下面是去除前和去除后，记录下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class ImageConverter &#123; private static List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(); public static void main(String[] args) &#123; System.out.println(&quot;输入需要去水印的图片所在的根目录回车（支持递归子目录）：&quot;); Scanner input = new Scanner(System.in); String dir =&quot;C:\\\\Users\\\\zengwei\\\\Desktop\\\\112&quot;; String saveDir = &quot;C:\\\\Users\\\\zengwei\\\\Desktop&quot;; System.out.println(&quot;输入y开始&quot;); String comfrm = input.nextLine().trim(); if (comfrm.equals(&quot;y&quot;)) &#123; convertAllImages(dir, saveDir); &#125; else &#123; System.out.println(&quot;您输入的不是y程序,程序退出&quot;); &#125; /*String dir = &quot;E:\\\\data\\\\Desktop&quot;; String saveDir = &quot;E:\\\\data\\\\Desktop-convert&quot;;*/ //replaceFolderImages(dir); /*String srcFile = &quot;E:\\\\data\\\\image\\\\img38.png&quot;; String dstFile = &quot;E:\\\\data\\\\image\\\\img38.png&quot;; long begin = System.currentTimeMillis(); repleaceColor(srcFile, dstFile); long time = System.currentTimeMillis() - begin; System.out.println(time);*/ &#125; private static void convertAllImages(String dir, String saveDir) &#123; File dirFile = new File(dir); File saveDirFile = new File(saveDir); dir = dirFile.getAbsolutePath(); saveDir = saveDirFile.getAbsolutePath(); loadImages(new File(dir)); for (File file : fileList) &#123; String filePath = file.getAbsolutePath(); String dstPath = saveDir + filePath.substring(filePath.indexOf(dir) + dir.length(), filePath.length()); System.out.println(&quot;converting: &quot; + filePath); replaceColor(file.getAbsolutePath(), dstPath); &#125; &#125; public static void loadImages(File f) &#123; if (f != null) &#123; if (f.isDirectory()) &#123; File[] fileArray = f.listFiles(); if (fileArray != null) &#123; for (int i = 0; i &lt; fileArray.length; i++) &#123; //递归调用 loadImages(fileArray[i]); &#125; &#125; &#125; else &#123; String name = f.getName(); if (name.endsWith(&quot;png&quot;) || name.endsWith(&quot;jpg&quot;)) &#123; fileList.add(f); &#125; &#125; &#125; &#125; private static void replaceFolderImages(String dir) &#123; File dirFile = new File(dir); File[] files = dirFile.listFiles(new FileFilter() &#123; public boolean accept(File file) &#123; String name = file.getName(); if (name.endsWith(&quot;png&quot;) || name.endsWith(&quot;jpg&quot;)) &#123; return true; &#125; return false; &#125; &#125;); for (File img : files) &#123; replaceColor(img.getAbsolutePath(), img.getAbsolutePath()); &#125; &#125; private static void replaceColor(String srcFile, String dstFile) &#123; try &#123; Color color = new Color(255, 195, 195); replaceImageColor(srcFile, dstFile, color, Color.WHITE); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void replaceImageColor(String file, String dstFile, Color srcColor, Color targetColor) throws IOException &#123; URL http; if (file.trim().startsWith(&quot;https&quot;)) &#123; http = new URL(file); HttpsURLConnection conn = (HttpsURLConnection) http.openConnection(); conn.setRequestMethod(&quot;GET&quot;); &#125; else if (file.trim().startsWith(&quot;http&quot;)) &#123; http = new URL(file); HttpURLConnection conn = (HttpURLConnection) http.openConnection(); conn.setRequestMethod(&quot;GET&quot;); &#125; else &#123; http = new File(file).toURI().toURL(); &#125; BufferedImage bi = ImageIO.read(http.openStream()); if(bi == null)&#123; return; &#125; Color wColor = new Color(255, 255, 255); for (int i = 0; i &lt; bi.getWidth(); i++) &#123; for (int j = 0; j &lt; bi.getHeight(); j++) &#123; //System.out.println(bi.getRGB(i, j)); int color = bi.getRGB(i, j); Color oriColor = new Color(color); int red = oriColor.getRed(); int greed = oriColor.getGreen(); int blue = oriColor.getBlue(); //粉色 if (greed &lt; 190 || blue &lt; 190) &#123; &#125; else &#123; if (red == 255 &amp;&amp; greed &gt; 180 &amp;&amp; blue &gt; 180) &#123; bi.setRGB(i, j, wColor.getRGB()); &#125; &#125; &#125; &#125; String type = file.substring(file.lastIndexOf(&quot;.&quot;) + 1, file.length()); Iterator&lt;ImageWriter&gt; it = ImageIO.getImageWritersByFormatName(type); ImageWriter writer = it.next(); File f = new File(dstFile); f.getParentFile().mkdirs(); ImageOutputStream ios = ImageIO.createImageOutputStream(f); writer.setOutput(ios); writer.write(bi); bi.flush(); ios.flush(); ios.close(); &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zengwei123.github.io/categories/笔记/"}],"tags":[]},{"title":"第三方库Gson","slug":"第三方库Gson","date":"2017-02-21T08:26:48.000Z","updated":"2018-10-12T08:29:22.424Z","comments":true,"path":"2017/02/21/第三方库Gson/","link":"","permalink":"https://zengwei123.github.io/2017/02/21/第三方库Gson/","excerpt":"","text":"JSON是一种文本形式的数据交换格式，它比XML更轻量、比二进制容易阅读和编写，调式也更加方便。而Gson就是一种解析JSON文本形式的库。 Gson能够将javaBean转成JSON格式，也能够将JSON转成JavaBean,下面我们来看Gson怎么使用的。 1.基本使用12345678910111213141516171819202122232425262728public class Test &#123; private String name; private int age; private String see; private String father; ... //省略其他toString、get、set、构造方法&#125;...public static void main(String[] s)&#123; /**转json**/ Test test=new Test(\"大傻逼\",11,\"男\",\"大蠢货\"); //主要下下面两行 Gson gson=new Gson(); String jsonData = gson.toJson(test); System.out.println(jsonData); /** * &#123;\"name\":\"大傻\",\"age\":33,\"see\":\"男\",\"father\":\"大臭\"&#125; * 转javaBean **/ String jsonData=\"&#123;\\\"name\\\":\\\"大傻\\\",\\\"age\\\":33,\\\"see\\\":\\\"男\\\",\\\"father\\\":\\\"大臭\\\"&#125;\"; Gson gson=new Gson(); Test test = gson.fromJson(jsonData, Test.class); System.out.println(test.toString());&#125;... 上面就是一个普通的javaBean的序列化与反序列换功能，用到的是toJson()和fromJson()两个方法。有时候我们的对象并不是这样简单的，里面可能有集合有对象有数组，那么该如何使用？这里的化跟上面的使用方法是一样的。 2.Gson注解主要有两个重要的注解@SerializedName和@Expose，前者主要是用来指定该字段在JSON中对应的字段名称，后者能够指定该字段是否能够序列化或者反序列化。 1.首先来看看@SerializedName注解，这个注解可以将改变字段的名字，使用场景，比如：后台给了一串json数据，但是他的字段名跟你的字段名起的不一样，这样子就可以使用这个注解来进行解析，可以不用统一前后端的命名。123456789public class Test2 &#123; private String occupation; private int wages; private String company; @SerializedName(\"测试\") //注解修改输出的字段名称 private Test test; ... //省略其他toString、get、set、构造方法&#125; 下面序列化输出 下面反序列化，如果后台给的数据是上面样的，但是我们不指定字段名，反序列化输出就是这样的。 可以注意到test这个对象是空的，但是我们指定后呢就可以正常输出了 这里，为POJO字段提供备选属性名SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。注：alternate需要2.4版本12@SerializedName(value=\"测试\",alternate=&#123;\"a\",\"b\"&#125;) private Test test; 当上面的三个属性(测试、a、b)都中出现任意一个时均可以得到正确的结果。当多种情况同时出时，以最后一个出现的值为准。 2.再来看看@Expose这个注解，有时候我们序列化或者反序列化的时候，有一个字段我不想看到他就可以用这个注解来指定,serialize用来指定序列化是否输出，deserialize是用来指定反序列化是否输出，true为输出，false为不输出1234567891011121314@Expose(serialize =true,deserialize =true) private String name; @Expose(serialize =false,deserialize =false) private int age; @Expose(serialize =true,deserialize =true) private String see; @Expose(serialize =false,deserialize =false) private String father; ... //省略其他toString、get、set、构造方法&#125;.........................//这种情况的话，Gson的使用方式就有点变化了 Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create(); //需要这样来获取 3.Gson使用泛型当我们想用Gson来输出集合的时候，我们需要使用TypeToken来实现对泛型的支持123Gson gson = new Gson();...gson.toJson(arrayList, new TypeToken&lt;ArrayList&lt;String&gt;&gt;() &#123;&#125;.getType()); 我们在实际开发中是不可能只有一个Model的，会有多个，但是在使用序列化和反序列化的同时候不可能给每一个Model都写一方法。知道Gson可以支持泛型，那么我们就来进行一下封装。12345678910111213141516public class TJson&lt;T&gt; &#123; private String state; //说明 private String code; //状态码 private T date; //这个就是我们实际的数据 ... //省略其他toString、get、set、构造方法&#125;...public static void main(String[] s)&#123; /**泛型封装**/ TJson&lt;Test&gt; testTJson=new TJson&lt;Test&gt;(\"ok_error\",\"0\",new Test(\"大傻逼\",11,\"男\",\"大蠢货\")); Gson gson = new Gson(); String s1=gson.toJson(testTJson, new TypeToken&lt;TJson&lt;Test&gt;&gt;() &#123;&#125;.getType()); System.out.println(s1);&#125;... 输出后就是下面这个样子 贴一个Gson学习的帖子:https://www.jianshu.com/p/e740196225a4 贴一个封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class GsonUtil &#123; private static Gson gson = null; static &#123; if (gson == null) &#123; gson = new Gson(); &#125; &#125; private GsonUtil() &#123; &#125; /** * 转成json * * @param object * @return */ public static String GsonString(Object object) &#123; String gsonString = null; if (gson != null) &#123; gsonString = gson.toJson(object); &#125; return gsonString; &#125; /** * 转成bean * * @param gsonString * @param cls * @return */ public static &lt;T&gt; T GsonToBean(String gsonString, Class&lt;T&gt; cls) &#123; T t = null; if (gson != null) &#123; t = gson.fromJson(gsonString, cls); &#125; return t; &#125; /** * 转成list * 泛型在编译期类型被擦除导致报错 * @param gsonString * @param cls * @return */ public static &lt;T&gt; List&lt;T&gt; GsonToList(String gsonString, Class&lt;T&gt; cls) &#123; List&lt;T&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;T&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成list * 解决泛型问题 * @param json * @param cls * @param &lt;T&gt; * @return */ public &lt;T&gt; List&lt;T&gt; jsonToList(String json, Class&lt;T&gt; cls) &#123; Gson gson = new Gson(); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); JsonArray array = new JsonParser().parse(json).getAsJsonArray(); for(final JsonElement elem : array)&#123; list.add(gson.fromJson(elem, cls)); &#125; return list; &#125; /** * 转成list中有map的 * * @param gsonString * @return */ public static &lt;T&gt; List&lt;Map&lt;String, T&gt;&gt; GsonToListMaps(String gsonString) &#123; List&lt;Map&lt;String, T&gt;&gt; list = null; if (gson != null) &#123; list = gson.fromJson(gsonString, new TypeToken&lt;List&lt;Map&lt;String, T&gt;&gt;&gt;() &#123; &#125;.getType()); &#125; return list; &#125; /** * 转成map的 * * @param gsonString * @return */ public static &lt;T&gt; Map&lt;String, T&gt; GsonToMaps(String gsonString) &#123; Map&lt;String, T&gt; map = null; if (gson != null) &#123; map = gson.fromJson(gsonString, new TypeToken&lt;Map&lt;String, T&gt;&gt;() &#123; &#125;.getType()); &#125; return map; &#125;","categories":[{"name":"第三方库","slug":"第三方库","permalink":"https://zengwei123.github.io/categories/第三方库/"}],"tags":[]},{"title":"Android-Snackbar","slug":"Android-Snackbar","date":"2017-02-14T03:05:43.000Z","updated":"2018-09-29T03:10:41.655Z","comments":true,"path":"2017/02/14/Android-Snackbar/","link":"","permalink":"https://zengwei123.github.io/2017/02/14/Android-Snackbar/","excerpt":"","text":"Snackbar基本介绍Snackbar是Android Support Design Library库中的一个控件，可以在屏幕底部快速弹出消息，比Toast更加好用，功能类似于Toast的一种轻量级反馈消息，Snackbar是从底部弹出消息的。` 使用,这里的view可以填你的根布局，或者findViewById(android.R.id.content)123Snackbar.make(view, message_text, duration) .setAction(action_text, click_listener) .show(); make()方法是生成Snackbar的。Snackbar需要一个控件容器view用来容纳，官方推荐使用CoordinatorLayout来确保Snackbar和其他组件的交互，比如滑动取消Snackbar、Snackbar出现时FloatingActionButton上移。显示时间duration有三种类型LENGTH_SHORT、LENGTH_LONG和LENGTH_INDEFINITE。setAction()方法可设置Snackbar右侧按钮，增加进行交互事件。如果不使用setAction()则只显示左侧message。123456Snackbar.make(coordinatorLayout,\"这是massage\", Snackbar.LENGTH_LONG).setAction(\"这是action\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,\"你点击了action\",Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); 自定义SnackbarSnackbar和Toast的默认样式都很单一，但是有时我们希望把不同类型信息区别显示，从而使用户更容易注意到提示信息。所以使Snackbar变色是一个好主意。下面的代码就可以修改他的背景颜色，setActionTextColor()这个方法可以修改Action颜色1234567public static void setSnackbarColor(Snackbar snackbar, int messageColor, int backgroundColor) &#123; View view = snackbar.getView();//获取Snackbar的view if(view!=null)&#123; view.setBackgroundColor(backgroundColor);//修改view的背景色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(messageColor);//获取Snackbar的message控件，修改字体颜色 &#125;&#125; 显示和隐藏时的回调在显示Snackbar或隐藏Snackbar时需要做一些事情，这时候就要用到Callback了，通过addCallback方法,以前有个setCallback现在过时了，实现Snackbar.Callback这个抽象类，里面有onDismissed()和onShown()两个抽象方法，onShown()是显示的时候调用，onDismissed()在隐藏的时候调用。12345678910111213141516Snackbar.make(view, \"我就是Snackbar!\", Snackbar.LENGTH_LONG).setAction(\"Action\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;) .addCallback(new Snackbar.Callback()&#123; @Override public void onDismissed(Snackbar transientBottomBar, int event) &#123; super.onDismissed(transientBottomBar, event); &#125; @Override public void onShown(Snackbar sb) &#123; super.onShown(sb); &#125; &#125;).show(); 相关属性设置123456789101112131415161718Snackbar snackbar = Snackbar.make(coordinatorLayout, \"Action 被点击\", Snackbar.LENGTH_SHORT); snackbar.setText(\"动态文本\");//动态设置文本显示内容 snackbar.setActionTextColor(Color.RED);//动态设置Action文本的颜色 snackbar.setDuration(5000);//动态设置显示时间 View snackbarView = snackbar.getView();//获取Snackbar显示的View对象 //获取显示文本View,并设置其显示颜色 ((TextView) snackbarView.findViewById(android.support.design.R.id.snackbar_text)).setTextColor(Color.BLUE); //获取Action文本View，并设置其显示颜色 ((TextView) snackbarView.findViewById(android.support.design.R.id.snackbar_action)).setTextColor(Color.BLUE); //设置Snackbar的背景色 snackbarView.setBackgroundColor(Color.GREEN); //设置Snackbar显示的位置 ViewGroup.LayoutParams params = snackbarView.getLayoutParams(); CoordinatorLayout.LayoutParams layoutParams = new CoordinatorLayout.LayoutParams(params.width, params.height); layoutParams.gravity = Gravity.CENTER_VERTICAL;//垂直居中 snackbarView.setLayoutParams(layoutParams); Snackbar与Dialog和Toast的比较Dialog模态对话框。也就说，此刻该对话框中的内容获取了焦点，想要操作对话框以外的功能，必须先对该对话框进行响应。应用场景：对于删除确认、版本更新等重要性提示信息，需要用户做出选择的情况下，使用Dialog。 Toast非模态提示框。也就说提示框的显示并不影响我们对其他地方的操作，Toast无法手动控制隐藏，需要设置Toast的显示时长，一旦显示时间结束，Toast会自动消失。如果多次点击并显示Toast，就会出现Toast重复创建并显示，给用户造成一种Toast长时间不隐藏的幻觉。应用场景：对于无网络提示、删除成功、发布操作完成等这类不重要的提示性信息，使用Toast； SnackbarSnackbar和Toast比较相似，但是用途更加广泛，并且它是可以和用户进行交互的。Snackbar使用一个动画效果从屏幕的底部弹出来，过一段时间后也会自动消失。应用场景：删除操作时，弹出Snackbar用于确认删除操作；消息发送失败时，弹出Snackbar，用于重新发送操作；当然重要的是与MD组件相结合，用户体验效果更佳。","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"android-CoordinatorLayout之Behavior","slug":"android-CoordinatorLayout之Behavior","date":"2017-02-11T06:51:32.000Z","updated":"2018-09-28T07:03:01.229Z","comments":true,"path":"2017/02/11/android-CoordinatorLayout之Behavior/","link":"","permalink":"https://zengwei123.github.io/2017/02/11/android-CoordinatorLayout之Behavior/","excerpt":"","text":"1. 简单使用CoordinatorLayout作为一个中间桥梁性质的布局，协调着内部的childView。之前对CoordinatorLayout有点误解，以为需要配合AppBarLayout才有一些比较炫酷的特效，大错特错，Behavior是CoordinatorLayout能够有协调作用以及能支持各种炫酷特效的的关键因素 1.1 布局文件中使用12345678910111213141516171819202122232425&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:background=\"#ffffff\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/title\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:background=\"#ff0000\" android:gravity=\"center\" android:text=\"Hello World\" android:textColor=\"#ffffff\" android:textSize=\"18sp\" app:layout_behavior=\"@string/behavior_sample_title\" /&gt; &lt;com.example.zengwei.coord.MoveView android:text=\"你好\" android:textColor=\"#2b2b2b\" android:gravity=\"center\" android:background=\"#0188FB\" android:layout_marginTop=\"200dp\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 最关键的地方就在于app:layout_behavior，利用这个属性来确定的绑定的目标childView 指定绑定目标有3种方式： 1.在xml布局通过app:layout_behavior2.在Java代码中，child.getLayoutParams().setBehavior()来指定3.在目标childView类上，通过@DefaultBehavior来指定 1.2 MoveViewMoveView就是一个继承TextView的很简单的自定义View123456789101112131415161718192021222324252627public class MoveView extends TextView &#123; private float lastX, lastY; public MoveView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int action = event.getAction(); float x = event.getRawX(); float y = event.getRawY(); if (action == MotionEvent.ACTION_MOVE) &#123; CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) getLayoutParams(); //计算当前的左上角坐标 float left = layoutParams.leftMargin + x - lastX; float top = layoutParams.topMargin + y - lastY; //设置坐标 layoutParams.leftMargin = (int) left; layoutParams.topMargin = (int) top; setLayoutParams(layoutParams); &#125; lastX = x; lastY = y; return true; &#125;&#125; 主要就是重写onTouchEvent()来使MoveView可以根据手指滑动在屏幕改变位置 1.3 一个简单的自定义Behavior123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SampleTitleBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123; // 列表顶部和title底部重合时，列表的滑动距离。 private float deltaY; boolean aBoolean=true; public SampleTitleBehavior() &#123; &#125; public SampleTitleBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * 使用该Behavior的View要监听哪个类型的View的状态变化。 * 其中参数parant代表CoordinatorLayout，child代表使用该Behavior的View，dependency代表要监听的View。 * 这里要监听RecyclerView * @param parent * @param child * @param dependency * @return */ @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return dependency instanceof MoveView; &#125; /** * 当被监听的View状态变化时会调用该方法，参数和上一个方法一致。 * 所以我们重写该方法，当MoveView的位置变化时，进而改变title的位置。 * @param parent * @param child * @param dependency * @return */ @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; if(aBoolean)&#123; deltaY=dependency.getY(); aBoolean=false; &#125; if(deltaY-dependency.getY()&lt;=150)&#123; child.setY(dependency.getY()-deltaY); &#125; return true; &#125;&#125; CoordinatorLayout.Behavior这里使用泛型将绑定的childView限制为了TextView，可以根据实际需求来指定类型，也可以直接指定为View 注意：当在布局文件中使用了Behavior后，Behavior代码中确定的交互行为便直接奏效，初始化第一次加载CoordinatorLayout时，使用了Behavior的ChildView受到onDependentViewChanged()方法的影响，第一次加载的位置也会受到影响，导致和布局文件中指定的位置不相同 官方有好几个非常好的学习资料，例如：android.support.design.widget.AppBarLayout$ScrollingViewBehavior 一个依赖AppBarLayout后，处理滑动事件的Behavior，对Behavior中的属性及方法有了大概了解后，可以学习具体细节的设计和优化 2. Behavior 行为需要注意的是Behavior可以几乎包括所有的交互行为，配合ViewDragHelper应该能够实现出一些很炫酷的交互效果 2.1 常用的方法构造方法有两个：默认：public Behavior() {}布局：public Behavior(Context context, AttributeSet attrs) { }两个构造方法也比较容易理解，一个是默认的空参的构造方法，一个是带有布局属性AttributeSet的方法，有了这个构造方法，可以直接在布局文件中使用 根据Behavior的特性，可以将内部的方法分以下类： 测量与布局：12测量：public boolean onMeasureChild()&#123;&#125;布局：public boolean onLayoutChild()&#123;&#125; 特定状态：1234567891011121314151617181920212223242526//当Behavior添加到参数实例时，回调public void onAttachedToLayoutParams()&#123;&#125;//当Behavior与参数实例分离时，回调public void onDetachedFromLayoutParams()&#123;&#125;//当Behavior关联的对象想要定位到特定的矩形时，回调public boolean onRequestChildRectangleOnScreen()&#123;&#125;//当一个ChildView设置为回避属性时，回调public boolean getInsetDodgeRect()&#123;&#125;//当窗口发生改变时，回调public WindowInsetsCompat onApplyWindowInsets()&#123;&#125;//需要保存临时状态信息，回调public Parcelable onSaveInstanceState()&#123;&#125;//需要恢复临时状态信息，回调public void onRestoreInstanceState()&#123;&#125;//作用未知public int getScrimColor()&#123;&#125; //作用未知public float getScrimOpacity()&#123;&#125; 确定依赖与绑定对象：12//根据参数来确定依赖与绑定对象public boolean layoutDependsOn()&#123;&#125; 当依赖对象发生改变时：12345//当依赖对象发生改变，包括位置，大小，颜色，进行回调public boolean onDependentViewChanged()&#123;&#125;//当依赖对象被移除时，进行回调public void onDependentViewRemoved()&#123;&#125; 事件相关：12345//拦截事件，在CoordinatorLayout把事件分发到childView之前public boolean onInterceptTouchEvent()&#123;&#125;//消费事件public boolean onTouchEvent()&#123;&#125; 嵌套滑动：1234567891011121314151617181920//CoordinatorLayout中的滑动嵌套childView开始启动一次嵌套滚动时，回调public boolean onStartNestedScroll()&#123;&#125;//嵌套滑动结束时，回调public void onStopNestedScroll()&#123;&#125;//当一次嵌套滑动被CoordiantorLayout识别并确定时，进行回调public void onNestedScrollAccepted()&#123;&#125;//嵌套滚动正在进行中并且绑定目标childView已经开始滚动或者被CoordinatorLayout接受后试图滚动public void onNestedScroll()&#123;&#125;//嵌套滚动正在准备更新进度，并且是在绑定目标childView已经出现滚动距离之前，回调public void onNestedPreScroll()&#123;&#125;//当嵌套滚动的childView正在开始fling或者一个动作确认为flingpublic boolean onNestedFling()&#123;&#125;//当滑动嵌套childView检测到适当的条件，马上开始一次fling事件前回调public boolean onNestedPreFling()&#123;&#125; 暂时就这么分，分类并不算合理，也无所谓，目的是以后自己回头来看时，能比较清晰能快速定位方法是干嘛的转：https://www.jianshu.com/p/9fdd271541d9","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android-CoordinatorLayout","slug":"Android-CoordinatorLayout","date":"2017-02-08T02:38:25.000Z","updated":"2018-09-28T07:00:23.492Z","comments":true,"path":"2017/02/08/Android-CoordinatorLayout/","link":"","permalink":"https://zengwei123.github.io/2017/02/08/Android-CoordinatorLayout/","excerpt":"","text":"CoordinatorLayout被称为联动布局，这是Design Support Library中最重要与最难的部分。首先我们要把CoordinatorLayout作为根布局,导入下面的依赖 compile ‘com.android.support:design:26.1.0’ 1.有时候我们会看到一个底部有一个块，然后可以拖上来成为一个布局，类似于下面这种 要使用这种效果只要两个代码,第一个是设置露出的高度，第二个一定要这么写，然后你就可以拖动将布局拖出来了1234...app:behavior_peekHeight=\"40dp\" app:layout_behavior=\"@string/bottom_sheet_behavior\"... 想要改变脱出后头部的样式和布局，那么你就需要再代码里面设置了123456789101112131415161718192021222324252627282930313233343536373839private RelativeLayout rsb; private TextView text,text1; private BottomSheetBehavior behavior; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout); /**根布局**/ rsb=findViewById(R.id.rsb); text=findViewById(R.id.text); text1=findViewById(R.id.text1); behavior= BottomSheetBehavior.from(rsb); behavior.setBottomSheetCallback(new BottomSheetBehavior.BottomSheetCallback() &#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &#123; /**滑动结束回调方法，BottomSheetBehavior状态的改变*/ if(newState==BottomSheetBehavior.STATE_EXPANDED)&#123; /**当结束后是滑动出来的**/ text1.setVisibility(View.VISIBLE); &#125;else if(newState==BottomSheetBehavior.STATE_COLLAPSED)&#123; /**当结束后是收缩进去的**/ text.setVisibility(View.VISIBLE); bottomSheet.setAlpha(1f); &#125; &#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &#123; /**滑动回调方法，slideOffset是所占高度的比例，可以用这个来做一些动画*/ bottomSheet.setAlpha(slideOffset); if(text1.getVisibility()==View.GONE)&#123; /**滑动开始如果 点击收缩 按钮为隐藏**/ text.setVisibility(View.GONE); &#125;else&#123; /**滑动开始如果 点击收缩 按钮为显示**/ text1.setVisibility(View.GONE); &#125; &#125; &#125;); &#125; 下面放出布局代码1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/coordinator\" android:background=\"#ffffff\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;RelativeLayout android:id=\"@+id/rsb\" app:behavior_peekHeight=\"40dp\" app:layout_behavior=\"@string/bottom_sheet_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/text\" android:text=\"拉出\" android:background=\"#52D3FF\" android:gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" /&gt; &lt;TextView android:id=\"@+id/text1\" android:text=\"点击收缩\" android:gravity=\"center\" android:background=\"#52D3FF\" android:visibility=\"gone\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" /&gt; &lt;RelativeLayout android:background=\"#ff0000\" android:layout_marginTop=\"40dp\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 2.看gif 想要实现这种效果也很简单，将FloatingActionButton放在CoordinatorLayout里面，代码中将CoordinatorLayout传给Snackbar就行了123...Snackbar.make(coordinatorLayout,\"你好吗\",Snackbar.LENGTH_LONG).show();.. 3.AppBarLayout子View的动作内部的子View通过在布局中加app:layout_scrollFlags设置执行的动作，那么app:layout_scrollFlags可以设置哪些动作呢？分别如下：（1） scroll:值设为scroll的View会跟随滚动事件一起发生移动。（2） enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。（3） exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。（4） enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。123456789101112131415161718192021&lt;android.support.design.widget.AppBarLayout android:background=\"#ff0000\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\"&gt; &lt;android.support.v7.widget.Toolbar app:title=\"标题\" app:layout_scrollFlags=\"scroll|enterAlwaysCollapsed|enterAlways\" //改这里就行了，混合使用 android:layout_width=\"match_parent\" android:minHeight=\"50dp\" android:gravity=\"bottom\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyle\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; 4.实现下面这种效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/coordinator\" android:background=\"#ffffff\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/avps\" android:background=\"#cccccc\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/avps1\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;RelativeLayout app:layout_collapseMode=\"parallax\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:src=\"@drawable/as\" android:scaleType=\"centerCrop\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;TextView android:textColor=\"#ffffff\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_alignParentStart=\"true\" android:textSize=\"30sp\" android:text=\"你自己想要的布局\" /&gt; &lt;/RelativeLayout&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=\"match_parent\" app:layout_collapseMode=\"pin\" android:layout_height=\"50dp\"&gt; &lt;TextView android:textColor=\"#ffffff\" android:text=\"返回\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:textColor=\"#ffffff\" android:text=\"分享\" android:gravity=\"right\" android:paddingRight=\"15dp\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:textColor=\"#2b2b2b\" android:text=\"a\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/FloatingActionButton\" app:rippleColor=\"#cccccc\" app:backgroundTint=\"#56abe4\" android:layout_gravity=\"right|bottom\" android:layout_marginRight=\"15dp\" android:layout_marginBottom=\"15dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 监听事件,1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class AppBarStateChangeListener implements AppBarLayout.OnOffsetChangedListener &#123; public enum State &#123; EXPANDED, COLLAPSED, IDLE &#125; private State mCurrentState = State.IDLE; @Override public final void onOffsetChanged(AppBarLayout appBarLayout, int i) &#123; if (i == 0) &#123; if (mCurrentState != State.EXPANDED) &#123; onStateChanged(appBarLayout, State.EXPANDED); &#125; mCurrentState = State.EXPANDED; &#125; else if (Math.abs(i) &gt;= appBarLayout.getTotalScrollRange()) &#123; if (mCurrentState != State.COLLAPSED) &#123; onStateChanged(appBarLayout, State.COLLAPSED); &#125; mCurrentState = State.COLLAPSED; &#125; else &#123; if (mCurrentState != State.IDLE) &#123; onStateChanged(appBarLayout, State.IDLE); &#125; mCurrentState = State.IDLE; &#125; &#125; public abstract void onStateChanged(AppBarLayout appBarLayout, State state);&#125;--------------------------------------------------------------------------public class Coord3 extends AppCompatActivity &#123; private FloatingActionButton floatingActionButton; private CoordinatorLayout coordinatorLayout; private BottomSheetBehavior behavior; private AppBarLayout avps; private CollapsingToolbarLayout avps1; public static int expendedtag=2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout3); floatingActionButton=findViewById(R.id.FloatingActionButton); coordinatorLayout=findViewById(R.id.coordinator); floatingActionButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(coordinatorLayout,\"你好吗\",Snackbar.LENGTH_LONG).show(); &#125; &#125;); avps=findViewById(R.id.avps); avps1=findViewById(R.id.avps1); avps1.setTitle(\"Title\"); avps.addOnOffsetChangedListener(new AppBarStateChangeListener() &#123; @Override public void onStateChanged(AppBarLayout appBarLayout, State state) &#123; if( state == State.EXPANDED ) &#123; //展开状态 Toast.makeText(Coord3.this, \"展开\", Toast.LENGTH_SHORT).show(); &#125;else if(state == State.COLLAPSED)&#123; //折叠状态 Toast.makeText(Coord3.this, \"折叠\", Toast.LENGTH_SHORT).show(); avps1.setContentScrimColor(Color.parseColor(\"#777777\")); //设置这个可以展现出那种透明的感觉 &#125;else &#123; //中间状态 Toast.makeText(Coord3.this, \"中间\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 app:statusBarScrim=”@android:color/transparent”，并且在onCreate中调用getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)将状态栏设置为透明就好啦~","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android对话框","slug":"Android对话框","date":"2017-02-03T01:50:14.000Z","updated":"2018-09-18T02:09:12.488Z","comments":true,"path":"2017/02/03/Android对话框/","link":"","permalink":"https://zengwei123.github.io/2017/02/03/Android对话框/","excerpt":"","text":"对话框是我们在开发者经常会用到的东西，他通常在进行一些不可逆操作时候用来提示用户。1.普通对话框1234567891011121314151617181920AlertDialog dialog = new AlertDialog.Builder(this) .setIcon(R.mipmap.icon)//设置标题的图片 .setTitle(\"我是对话框\")//设置对话框的标题 .setMessage(\"我是对话框的内容\")//设置对话框的内容 //设置对话框的按钮 .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, \"点击了取消按钮\", Toast.LENGTH_SHORT).show(); dialog.dismiss(); &#125; &#125;) .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, \"点击了确定的按钮\", Toast.LENGTH_SHORT).show(); dialog.dismiss(); &#125; &#125;).create(); dialog.show(); AlertDialog类中有一个静态内部类Builder。所以可以看出对话框使用了一个建造者模式在调用函数的时候就可以一直直点点点链式调用。 需要注意的是：NegativeButton这个按钮是在对话框的左边,PositiveButton在对话框的右边;如果你还想再加一个按钮也是可以的只需要在调用.setNeutralButton(“第三个按钮”,listener)即可。 2.列表对话框1234567891011121314151617181920212223final String items[] = &#123;\"我是Item一\", \"我是Item二\", \"我是Item三\", \"我是Item四\"&#125;; AlertDialog dialog = new AlertDialog.Builder(this) .setIcon(R.mipmap.icon)//设置标题的图片 .setTitle(\"列表对话框\")//设置对话框的标题 .setItems(items, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, items[which], Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;) .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;).create(); dialog.show(); 源码已经为我们预留好了设置方法，所以我们只需要调用.setItems()即可，第一个参数即要显示item的数组,第二个参数也就是点击item后的监听事件还是so easy的。 3.单选列表对话框1234567891011121314151617181920212223final String items[] = &#123;\"我是Item一\", \"我是Item二\", \"我是Item三\", \"我是Item四\"&#125;; AlertDialog dialog = new AlertDialog.Builder(this) .setIcon(R.mipmap.icon)//设置标题的图片 .setTitle(\"单选列表对话框\")//设置对话框的标题 .setSingleChoiceItems(items, 1, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(MainActivity.this, items[which], Toast.LENGTH_SHORT).show(); &#125; &#125;) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;) .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;).create(); dialog.show(); .setSingleChoiceItems(items, 1, listener)第一个参数:设置单选的资源数组;第二个参数:设置默认选中哪一项。 4.多选列表对话框12345678910111213141516171819202122232425262728293031final String items[] = &#123;\"我是Item一\", \"我是Item二\", \"我是Item三\", \"我是Item四\"&#125;; final boolean checkedItems[] = &#123;true, false, true, false&#125;; AlertDialog dialog = new AlertDialog.Builder(this) .setIcon(R.mipmap.icon)//设置标题的图片 .setTitle(\"多选对话框\")//设置对话框的标题 .setMultiChoiceItems(items, checkedItems, new DialogInterface.OnMultiChoiceClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) &#123; checkedItems[which] = isChecked; &#125; &#125;) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;) .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; for (int i = 0; i &lt; checkedItems.length; i++) &#123; if (checkedItems[i]) &#123; Toast.makeText(MainActivity.this, \"选中了\" + i, Toast.LENGTH_SHORT).show(); &#125; &#125; dialog.dismiss(); &#125; &#125;).create(); dialog.show(); .setMultiChoiceItems(items, checkedItems, listener)//第一个参数:设置单选的资源;第二个参数:设置默认选中哪几项（数组）; 5.半自定义列表对话框123456789101112131415161718192021View view = activity.getLayoutInflater().inflate(R.layout.layout2, null); final EditText editText = view.findViewById(R.id.editText); AlertDialog dialog = new AlertDialog.Builder(activity) .setIcon(R.mipmap.ic_launcher)//设置标题的图片 .setTitle(\"半自定义对话框\")//设置对话框的标题 .setView(view) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;) .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; String content = editText.getText().toString(); Toast.makeText(activity, content, Toast.LENGTH_SHORT).show(); dialog.dismiss(); &#125; &#125;).create(); dialog.show(); 布局12345678910111213&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;EditText android:id=\"@+id/editText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:ems=\"10\" android:inputType=\"textPersonName\" android:text=\"Name\" /&gt;&lt;/LinearLayout&gt; 6.完全自定义列表对话框首先我们需要自定义Dialog的style，让他自己本有的东西全部透明，然后在设置我们自己的内容就可以达到完全自定义的效果了。1234567891011121314151617&lt;!--对话框的样式--&gt; &lt;style name=\"NormalDialogStyle\"&gt; &lt;!--对话框背景 --&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; &lt;!--边框 --&gt; &lt;item name=\"android:windowFrame\"&gt;@null&lt;/item&gt; &lt;!--没有标题 --&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt; &lt;!-- 是否浮现在Activity之上 --&gt; &lt;item name=\"android:windowIsFloating\"&gt;true&lt;/item&gt; &lt;!--背景透明 --&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;false&lt;/item&gt; &lt;!-- 是否有覆盖 --&gt; &lt;item name=\"android:windowContentOverlay\"&gt;@null&lt;/item&gt; &lt;!--背景变暗--&gt; &lt;item name=\"android:backgroundDimEnabled\"&gt;true&lt;/item&gt; &lt;/style&gt; 代码1234567891011121314151617181920212223242526272829final Dialog dialog = new Dialog(activity, R.style.NormalDialogStyle); View view = View.inflate(activity, R.layout.dialog_normal, null); TextView cancel = view.findViewById(R.id.cancel); TextView confirm = view.findViewById(R.id.confirm); dialog.setContentView(view); //使得点击对话框外部不消失对话框 dialog.setCanceledOnTouchOutside(false); //设置对话框的大小 view.setMinimumHeight(300); Window dialogWindow = dialog.getWindow(); WindowManager.LayoutParams lp = dialogWindow.getAttributes(); lp.width = 500; lp.height = 500; //这里设置对话框的位置center是居中还可以设置bottom等 lp.gravity = Gravity.CENTER; dialogWindow.setAttributes(lp); cancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dialog.dismiss(); &#125; &#125;); confirm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dialog.dismiss(); &#125; &#125;); dialog.show(); 布局文件12345678910111213141516171819202122232425262728293031323334353637383940&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:background=\"#ffffff\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" android:text=\"TextView\" /&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignEnd=\"@+id/textView\" android:layout_alignRight=\"@+id/textView\" android:layout_below=\"@+id/textView\" android:text=\"TextView\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_below=\"@+id/textView2\" android:orientation=\"horizontal\"&gt; &lt;Button android:id=\"@+id/cancel\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button\" /&gt; &lt;Button android:id=\"@+id/confirm\" android:layout_weight=\"1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 计算屏幕宽高的工具类1234567891011121314151617181920212223242526272829303132public class ScreenSizeUtils &#123; private static ScreenSizeUtils instance = null; private int screenWidth, screenHeight; public static ScreenSizeUtils getInstance(Context mContext) &#123; if (instance == null) &#123; synchronized (ScreenSizeUtils.class) &#123; if (instance == null) instance = new ScreenSizeUtils(mContext); &#125; &#125; return instance; &#125; private ScreenSizeUtils(Context mContext) &#123; WindowManager manager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); DisplayMetrics dm = new DisplayMetrics(); manager.getDefaultDisplay().getMetrics(dm); screenWidth = dm.widthPixels;// 获取屏幕分辨率宽度 screenHeight = dm.heightPixels;// 获取屏幕分辨率高度 &#125; //获取屏幕宽度 public int getScreenWidth() &#123; return screenWidth; &#125; //获取屏幕高度 public int getScreenHeight() &#123; return screenHeight; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android6.0权限管理","slug":"Android6.0权限管理","date":"2017-02-01T02:06:53.000Z","updated":"2018-09-17T02:14:06.037Z","comments":true,"path":"2017/02/01/Android6.0权限管理/","link":"","permalink":"https://zengwei123.github.io/2017/02/01/Android6.0权限管理/","excerpt":"","text":"android 6.0 对权限管理，做了重新定义，导致项目的targetSdkVersion 是23 系统就会默认使用新的权限管理，也是6.0 的权限管理。如果项目的 targetSdkVersion小于23 系统还是使用旧的权限管理。6.0的权限管理与5.0之前的权限有什么不同呢？就是在6.0系统中的项目需要动态获取权限，让用户做出判断，是同意还是拒绝，像拍照定位等危险权限就需要去动态申请，但是同时也要在配置文件中配置。 一般我们获取权限的步骤时这样的：1.检查是否有权限2.权限没有时，获取权限3.用户拒绝时弹出对话框提示用户授予权限4.获取权限成功进入123456789101112131415161718192021222324252627282930313233343536..../**权限数组，将所有所需要的权限放在这里**/String[] permissions = &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_PHONE_STATE&#125;;/**用来判断是否有权限未授予权限**/List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;();.... /**权限判断和申请**/ private void initPermission() &#123; /**清空没有通过的权限**/ mPermissionList.clear(); /**逐个判断你要的权限是否已经通过**/ for (int i = 0; i &lt; permissions.length; i++) &#123; /** 这一个方法主要是主要用于检测某个权限是否已经被授予， * 方法返回值为PackageManager.PERMISSION_DENIED或者PackageManager.PERMISSION_GRANTED。 * 当返回DENIED就需要进行申请授权了。 **/ if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; /**添加还未授予的权限**/ mPermissionList.add(permissions[i]); &#125; &#125; /**申请权限**/ if (mPermissionList.size() &gt; 0) &#123; /** *有权限没有通过，需要申请* *该方法是异步的，第一个参数是Context；第二个参数是需要申请的权限的字符串数组； *第三个参数为requestCode，主要用于回调的时候检测。 *可以从方法名requestPermissions以及第二个参数看出，是支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权。 **/ ActivityCompat.requestPermissions(this, permissions, 100); &#125;else&#123; /**说明权限都已经通过，可以做你想做的事情去**/ mvpPresenter.init(); &#125; &#125; 在这个方法里我们就可以知道哪些权限没用获取了，然后提示用户授予权限，在授予权限的回调方法中判断用户是否授予了权限，重写onRequestPermissionsResult方法.首先验证requestCode定位到你的申请，然后验证grantResults对应于申请的结果，这里的数组对应于申请时的第二个权限字符串数组。如果你同时申请两个权限，那么grantResults的length就为2，分别记录你两个权限的申请结果。如果申请成功，就可以做你的事情了~123456789101112131415161718192021@Override/**获取点击权限的回调**/public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); boolean hasPermissionDismiss = false;//有权限没有通过 if (100 == requestCode) &#123; for (int i = 0; i &lt; grantResults.length; i++) &#123; if (grantResults[i] == -1) &#123; hasPermissionDismiss = true; &#125; &#125; //如果有权限没有被允许 if (hasPermissionDismiss) &#123; //打开提示授予权限对话框，跳转到系统设置权限页面，或者直接关闭页面，不让他继续访问 showPermissionDialog(); &#125;else&#123; //全部权限通过，可以进行下一步操作。。。 mvpPresenter.init(); &#125; &#125; &#125; 下面是对话框的代码123456789101112131415161718192021222324252627282930/** * 不再提示权限时的展示对话框 */ AlertDialog mPermissionDialog; String mPackName = \"com.example.zengwei.zwpushbox\"; private void showPermissionDialog() &#123; if (mPermissionDialog == null) &#123; mPermissionDialog = new AlertDialog.Builder(this).setMessage(\"已禁用权限，请手动授予\") .setPositiveButton(\"设置\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; /**这里是跳转到应用的权限授予页面**/ cancelPermissionDialog(); Uri packageURI = Uri.parse(\"package:\" + mPackName); Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI); startActivity(intent); &#125; &#125;) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //关闭页面或者做其他操作，直接关闭可能太流氓了，可以判断一下未授予的权限是不是一定得要然后在做操作 cancelPermissionDialog(); finish(); &#125; &#125;) .create(); &#125; mPermissionDialog.show(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android6.0权限管理","slug":"Android6.0权限管","date":"2017-02-01T02:06:53.000Z","updated":"2018-09-17T02:23:26.096Z","comments":true,"path":"2017/02/01/Android6.0权限管/","link":"","permalink":"https://zengwei123.github.io/2017/02/01/Android6.0权限管/","excerpt":"","text":"android 6.0 对权限管理，做了重新定义，导致项目的targetSdkVersion 是23 系统就会默认使用新的权限管理，也是6.0 的权限管理。如果项目的 targetSdkVersion小于23 系统还是使用旧的权限管理。6.0的权限管理与5.0之前的权限有什么不同呢？就是在6.0系统中的项目需要动态获取权限，让用户做出判断，是同意还是拒绝，像拍照定位等危险权限就需要去动态申请，但是同时也要在配置文件中配置。 一般我们获取权限的步骤时这样的：1.检查是否有权限2.权限没有时，获取权限3.用户拒绝时弹出对话框提示用户授予权限4.获取权限成功进入123456789101112131415161718192021222324252627282930313233343536..../**权限数组，将所有所需要的权限放在这里**/String[] permissions = &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_PHONE_STATE&#125;;/**用来判断是否有权限未授予权限**/List&lt;String&gt; mPermissionList = new ArrayList&lt;&gt;();.... /**权限判断和申请**/ private void initPermission() &#123; /**清空没有通过的权限**/ mPermissionList.clear(); /**逐个判断你要的权限是否已经通过**/ for (int i = 0; i &lt; permissions.length; i++) &#123; /** 这一个方法主要是主要用于检测某个权限是否已经被授予， * 方法返回值为PackageManager.PERMISSION_DENIED或者PackageManager.PERMISSION_GRANTED。 * 当返回DENIED就需要进行申请授权了。 **/ if (ContextCompat.checkSelfPermission(this, permissions[i]) != PackageManager.PERMISSION_GRANTED) &#123; /**添加还未授予的权限**/ mPermissionList.add(permissions[i]); &#125; &#125; /**申请权限**/ if (mPermissionList.size() &gt; 0) &#123; /** *有权限没有通过，需要申请* *该方法是异步的，第一个参数是Context；第二个参数是需要申请的权限的字符串数组； *第三个参数为requestCode，主要用于回调的时候检测。 *可以从方法名requestPermissions以及第二个参数看出，是支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权。 **/ ActivityCompat.requestPermissions(this, permissions, 100); &#125;else&#123; /**说明权限都已经通过，可以做你想做的事情去**/ mvpPresenter.init(); &#125; &#125; 在这个方法里我们就可以知道哪些权限没用获取了，然后提示用户授予权限，在授予权限的回调方法中判断用户是否授予了权限，重写onRequestPermissionsResult方法.首先验证requestCode定位到你的申请，然后验证grantResults对应于申请的结果，这里的数组对应于申请时的第二个权限字符串数组。如果你同时申请两个权限，那么grantResults的length就为2，分别记录你两个权限的申请结果。如果申请成功，就可以做你的事情了~123456789101112131415161718192021@Override/**获取点击权限的回调**/public void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); boolean hasPermissionDismiss = false;//有权限没有通过 if (100 == requestCode) &#123; for (int i = 0; i &lt; grantResults.length; i++) &#123; if (grantResults[i] == -1) &#123; hasPermissionDismiss = true; &#125; &#125; //如果有权限没有被允许 if (hasPermissionDismiss) &#123; //打开提示授予权限对话框，跳转到系统设置权限页面，或者直接关闭页面，不让他继续访问 showPermissionDialog(); &#125;else&#123; //全部权限通过，可以进行下一步操作。。。 mvpPresenter.init(); &#125; &#125; &#125; 下面是对话框的代码123456789101112131415161718192021222324252627282930/** * 不再提示权限时的展示对话框 */ AlertDialog mPermissionDialog; String mPackName = \"com.example.zengwei.zwpushbox\"; private void showPermissionDialog() &#123; if (mPermissionDialog == null) &#123; mPermissionDialog = new AlertDialog.Builder(this).setMessage(\"已禁用权限，请手动授予\") .setPositiveButton(\"设置\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; /**这里是跳转到应用的权限授予页面**/ cancelPermissionDialog(); Uri packageURI = Uri.parse(\"package:\" + mPackName); Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, packageURI); startActivity(intent); &#125; &#125;) .setNegativeButton(\"取消\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //关闭页面或者做其他操作，直接关闭可能太流氓了，可以判断一下未授予的权限是不是一定得要然后在做操作 cancelPermissionDialog(); finish(); &#125; &#125;) .create(); &#125; mPermissionDialog.show(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"第三方库Glide","slug":"第三方库Glide","date":"2017-01-20T03:59:53.000Z","updated":"2018-10-12T08:27:41.752Z","comments":true,"path":"2017/01/20/第三方库Glide/","link":"","permalink":"https://zengwei123.github.io/2017/01/20/第三方库Glide/","excerpt":"","text":"glide是一个图片加载的库依赖 compile ‘com.github.bumptech.glide:glide:3.7.0’使用glide很简单就是简简单单的一句123Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .into(image); with(Context context):Context支持 Activity Context Fragment FragmentActivity中四种类型load():支持网络资源、assets资源、Resources资源、File资源、Uri资源、字节数组into():在哪个imageview中显示 glide可以加载的资源类型12345Glide.with(this).load(\"http://pic9/258/a2.jpg\").into(iv); //网络资源Glide.with(this).load(\"file:///xxx.jpg\").into(iv); //file文件Glide.with(this).load(R.mipmap.ic_launcher).into(iv); //资源文件Glide.with(this).load(uri).into(iv); //uri资源Glide.with(this).load(byte[]).into(iv); //byte数组 不仅如此glide还可以加载动静态的gif12Glide.with(this).load(imageUrl).asBitmap().into(iv); //静态gif 其实就是一张图片Glide.with(this).load(imageUrl).asGif().into(iv); //动态gif 还可以加载本地的一个视频12String filePath = \"/storage/emulated/0/Pictures/example_video.mp4\"; //视频路径Glide.with(context).load(Uri.fromFile(new File( filePath))).into(iv); 我们有时候加载网络图片可能会失败，这时候我们可以设置一个加载失败的图片1234Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误的图片 .into(image) 当图片真在加载的时候如果什么都没有，会让用户感觉非常不好，这是我们可以设置一个正在加载时显示的图片12345Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误或失败后显示的图片 .placeholder(R.drawable.load) //正在加载时试显示的图片 .into(image) 还可以设置先加载缩略图123456Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误或失败后显示的图片 .placeholder(R.drawable.load) //正在加载时试显示的图片 .thumbnail(0.1f) //加载缩略图 .into(image) 我们还可以设置加载的动画，这个动画默认是淡入淡出123456789Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误或失败后显示的图片 .placeholder(R.drawable.load) //正在加载时试显示的图片 .thumbnail(0.1f) //加载缩略图 .crossFade(1000) // 可设置时长，默认“300ms” //.animate(R.anim.fade_in)设置自定义的动画 //.dontAnimate() 可以去除动画 .into(image) 有时候我们需要去设置图的大小,除了自己去设置，Glide还给我们提供了两种缩放方法123456789Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误或失败后显示的图片 .placeholder(R.drawable.load) //正在加载时试显示的图片 .thumbnail(0.1f) //加载缩略图 .override(width,height) //图片显示的分辨率 ，像素值 可以转化为DP再设置 //.centerCrop() CenterCrop 即缩放图像至填充到 ImageView内,裁剪额外的部分。ImageView会完全填充，但图像可能不会显示不全 //.fitCenter() fitCenter() 图片会按照imageview长宽中最小的边界作为依据,按比例缩放图像。该图像将会完全显示，但可能不会填满整个 ImageView。 .into(image) Glide还给我们提供了缓存的策略1234567891011121314151617181920Glide.with(this).load(\"http://nm/photo/1f/1f7a.jpg\").skipMemoryCache(true) //跳过缓存.into(iv);//设置缓存Glide.with(this).load(\"http://nm/photo/1f/1f7a.jpg\").diskCacheStrategy(DiskCacheStrategy.ALL).into(iv);//DiskCacheStrategy.ALL 缓存源资源和转换后的资源//DiskCacheStrategy.NONE 不做任何磁盘缓存//DiskCacheStrategy.RESULT 缓存转换后的资源//DiskCacheStrategy.SOURCE 缓存源资源/**还提供了清理缓存的方法**/Glide.get(this).clearDiskCache();//在子线程中进行Glide.get(this).clearMemory();//可以在主线程//获取文件缓存的路径，拿到路径之后我们就能够加载出缓存的图片Glide.with(context).load(imgUrl).downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).get(); 还可以自己设置缓存的路径1234567891011121314public class GlideModuleConfig implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123;//内部存储/Android/data/包名/cache/glide-imagesbuilder.setDiskCache(new ExternalCacheDiskCacheFactory(context, \"glide-images\", 2 * 1024 * 1024)); //将默认的RGB_565效果转换到ARGB_8888 builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; //不做处理 &#125;&#125; 然后在配置文件中配置，application节点下123&lt;meta-data android:name=\"包名.widget.GlideModuleConfig\" android:value=\"GlideModule\" /&gt; 同时我们还可设置图片的模糊度，像下面这样，这时我们需要在另外导入一个依赖，这是一个模糊的依赖 依赖compile ‘jp.wasabeef:glide-transformations:2.0.1’12345678Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .error(\"R.drawable.error\") //加载错误或失败后显示的图片 .placeholder(R.drawable.load) //正在加载时试显示的图片 .thumbnail(0.1f) // “23”：设置模糊度(在0.0到25.0之间)，默认”25\";\"4\":图片缩放比例,默认“1”。 .bitmapTransform(new BlurTransformation(context,23,4)) //模糊 .into(image) 利用这个库还可以进行裁剪圆角等12345678910//原图基础上变换设置圆形图Glide.with(context).load(url).bitmapTransform(new CropCircleTransformation(this)).into(iv); //原图基础上变换成圆图 +毛玻璃（高斯模糊）Glide.with(this).load(url).bitmapTransform(new BlurTransformation(this, 25), new CropCircleTransformation(this)).into(iv);//y圆角//如果是四周已经是圆角则RoundedCornersTransformation.CornerType.ALLGlide.with(this) .load(url) .bitmapTransform(new RoundedCornersTransformation(this, 30, 0, RoundedCornersTransformation.CornerType.BOTTOM)) .into(iv); 同时我们还可以对加载进行监听,注意：如果需要加载完成后设置图片透明度为0，则不能设置.placeholder(R.drawable.url)，否则达不到你想要的效果。12345678910111213141516Glide.with(this) .load(\"http://ww4.sinaimg.cn/large/610dc034gw1f96kp6faayj20u00jywg9.jpg\") .listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),\"资源加载异常\",Toast.LENGTH_SHORT).show(); return false; &#125; //这个用于监听图片是否加载完成 @Override public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),\"图片加载完成\",Toast.LENGTH_SHORT).show(); return false; &#125; &#125;) .into(image)","categories":[{"name":"第三方库","slug":"第三方库","permalink":"https://zengwei123.github.io/categories/第三方库/"}],"tags":[]},{"title":"Git上传及命令大全","slug":"Git上传及命令大全","date":"2017-01-15T03:52:03.000Z","updated":"2018-09-08T07:12:43.519Z","comments":true,"path":"2017/01/15/Git上传及命令大全/","link":"","permalink":"https://zengwei123.github.io/2017/01/15/Git上传及命令大全/","excerpt":"","text":"记录一下上传项目到github首先在github上面建立一个仓库 然后切换到自己的项目的的路径下面 1.输入git init，使Test文件夹加入git管理2.输入git add .（不要漏了“.”），将Test文件夹全部内容添加到git。3.输入git commit -m “你想要提交的信息”4.输入git remote add origin 这里填你自己项目仓库地址 ，连接你的guthub仓库。5.输入git push -u origin master，上传项目到Github。这里会要求输入Github的账号密码，按要求输入就可以。 最后出现下面这样就成功上传到仓库了 如果出现下面这样的情况，先git pull 再git push 下面贴个命令大全：https://www.cnblogs.com/vman/articles/Git_cmds.html 查看、添加、提交、删除、找回，重置修改文件 git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diff git diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录 git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理 查看、切换、创建和删除分支 git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase git merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用) git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理 git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理 git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理 GitHub git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库 git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","categories":[{"name":"GitHub-Git","slug":"GitHub-Git","permalink":"https://zengwei123.github.io/categories/GitHub-Git/"}],"tags":[]},{"title":"Android截图当前界面并且保存","slug":"Android截图当前界面并且保存","date":"2017-01-11T06:19:47.000Z","updated":"2018-09-03T06:21:49.607Z","comments":true,"path":"2017/01/11/Android截图当前界面并且保存/","link":"","permalink":"https://zengwei123.github.io/2017/01/11/Android截图当前界面并且保存/","excerpt":"","text":"获取屏幕保存成图片，其实就是一个截图功能，只不过这个截图是截不到状态栏的。看注释，通过下面的代码我们就得到了当前界面的Bitmap。1234567891011121314//获取当前屏幕的大小int width = activity.getWindow().getDecorView().getRootView().getWidth();int height = activity.getWindow().getDecorView().getRootView().getHeight();//生成相同大小的图片Bitmap temBitmap = Bitmap.createBitmap( width, height, Bitmap.Config.ARGB_8888 );//找到当前页面的跟布局View view = activity.getWindow().getDecorView().getRootView();//清除缓存view.destroyDrawingCache();//设置缓view.setDrawingCacheEnabled(true);view.buildDrawingCache();//从缓存中获取当前屏幕的图片temBitmap = view.getDrawingCache(); 拿到Bitmap之后我们就可以进行一些保存操作123456789101112131415try &#123; //保存路径，这个路径是项目的私有路径 File file=new File(context.getFilesDir().getPath()+\"/disk.jpg\"); file.delete(); FileOutputStream fos = new FileOutputStream(file); //图片，可以进行压缩，然后保存 temBitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos); //清空并关闭 fos.flush(); fos.close();&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"AS模拟器root","slug":"AS模拟器root","date":"2017-01-09T04:27:06.000Z","updated":"2018-08-31T04:30:35.205Z","comments":true,"path":"2017/01/09/AS模拟器root/","link":"","permalink":"https://zengwei123.github.io/2017/01/09/AS模拟器root/","excerpt":"","text":"当我们在Android studio中打开Android device monitor时，发现data目录不能打开，当我们去点击/data/目录时，发现什么都没有，这是怎么回事呢？ 原因是我们权限不够，当前的用户没有权限访问data目录。首先在sdk下找到，platform-tools目录，运行cmd，切换盘符到platform-tools目录。 1.输入adb shell命令 2.然后输入su，使得用户切换到root 3.输入chmod -R 777 /data/ 这是将/data/目录的权限改为777(表示任何人都可以访问和修改) 4.刷新一下Android device monitor，发现data目录可以打开了 5.经过上面的操作已经可以打开/data/data/了，但是导出文件会出现 transfer error: open failed: Permission deniedFailed to pull selection: open failed: Permission denied 6.我们来到终端，输入adb root，一般情况下这样就可以导出文件了，但是如果遇见出现了下面这种情况，这说明有多个设备在运行。 adb: unable to connect for root: more than one device/emulator 7.首先要查一下，是不是真的有多个设备或模拟器。输入adb devices，发现有下面这种情况8.那么我们就给他指定设备，运行adb -s emulator-5554 shell","categories":[{"name":"工具","slug":"工具","permalink":"https://zengwei123.github.io/categories/工具/"}],"tags":[]},{"title":"Android动画2","slug":"Android动画2","date":"2016-11-27T01:16:27.000Z","updated":"2018-08-22T07:43:05.488Z","comments":true,"path":"2016/11/27/Android动画2/","link":"","permalink":"https://zengwei123.github.io/2016/11/27/Android动画2/","excerpt":"","text":"安卓在5.0以后有一些新的动画： · Touch feedback（触摸反馈） · Reveal effect（揭露效果） · Activity transitions（Activity转换效果） · Curved motion（曲线运动） · View state changes（视图状态改变） 下面一个一个的来说 1.触摸反馈 顾名思义，触摸的时候给你一个反馈，最典型的就是Button默认的水波纹了，当使用了Material主题之后，波纹动画会自动安装到所有的控件上面。当然，我们也可以设置了，上面的第一种是设置波纹有边界，第二种是设置波纹超出边界。第二种需要5.0以上才行。这里注意：除了Button外，如果像TextView这些控件，需要给予点击事件才能够有效果。12android:background=\"?android:attr/selectableItemBackground\"android:background=\"?android:attr/selectableItemBackgroundBorderless\" 如果你觉得默认的颜色丑，那么你还可以自己区设置颜色，在drawable创建一个ripple的xml文件，android：background=”在这里引用就行”;123&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"#ffff00\" android:radius=\"200dp\"&gt; &lt;item android:drawable=\"@android:color/background_light\"&gt;&lt;/item&gt; &lt;!--把这个删除掉就是第二种无边框状态--&gt;&lt;/ripple&gt; 2.视图状态改变 除了这种水波纹之外，我们还可以定义自己的动画，使用android:stateListAnimator，这个东西，我们先看看效果：像这个翻转动画就是我们自己定义的，使用这个也很简单，在animator下创建一个XML文件，看下面的代码你可会发现是一个objectAnimator，这个跟属性动画的xml编写是一样的，android:state_pressed=”true” 按下false为抬起。1234567891011121314 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"true\"&gt; &lt;set&gt; &lt;objectAnimator android:duration=\"500\" android:propertyName=\"rotationX\" android:valueTo=\"360\" android:valueType=\"floatType\" /&gt; &lt;/set&gt; &lt;/item&gt; &lt;item android:state_pressed=\"false\"&gt; &lt;set&gt; &lt;objectAnimator android:duration=\"500\" android:propertyName=\"rotationX\" android:valueTo=\"0\" android:valueType=\"floatType\" /&gt; &lt;/set&gt; &lt;/item&gt;&lt;/selector&gt; 我们怎么使用这个动画呢？两种方法第一代码实现，第种二配置android:stateListAnimator=”@nimator/XXX.xml“12StateListAnimator stateListAnimator= AnimatorInflater.loadStateListAnimator(getApplicationContext(),R.animator.asd);textView.setStateListAnimator(stateListAnimator); 3.揭露效果 1234567Animator animator = ViewAnimationUtils.createCircularReveal(textView, textView.getWidth()/2, textView.getHeight()/2, textView.getWidth(),0); animator.setInterpolator(new AccelerateDecelerateInterpolator()); animator.setDuration(5000); animator.start(); 方法的第一个参数是你要操作的view,第二个是原中心的X方向中点，第三个是圆Y方向的中点，第四个是原开始的半径，第五个是结束时候的半径。 4.曲线运动 曲线运动很容易，就是画一个贝塞尔曲线出来，然后沿着轨迹运动，他的使用方法跟属性动画一样。123456789Path path = new Path(); path.moveTo(0, 0); path.quadTo(200, 200,400,0); ObjectAnimator mAnimator=ObjectAnimator.ofFloat(textView, View.X, View.Y, path); mAnimator.setDuration(2000); mAnimator.setEvaluator(new FloatEvaluator()); mAnimator.setRepeatCount(-1); mAnimator.setRepeatMode(ObjectAnimator.REVERSE); mAnimator.start(); 5.Activity转换效果 在Android L之前，我们可以在startActivity之后调用overridePendingTransition来指定Activity的转场动画。现在Android L给我们带来了更绚丽的转场动画。新的转场动画分为两大类，一种是普通的过渡动画，另一种是共享元素的过渡动画。 要想使用新的转场动画，可以继承Material Design主题后在style风格中指定： 12345678910111213&lt;style name=\"DefaultTheme\" parent=\"android:Theme.Material\"&gt; &lt;!-- 允许使用transitions --&gt; &lt;item name=\"android:windowContentTransitions\"&gt;true&lt;/item&gt; &lt;!-- 指定进入、退出、返回、重新进入时的transitions --&gt; &lt;item name=\"android:windowEnterTransition\"&gt;@transition/explode&lt;/item&gt; &lt;item name=\"android:windowExitTransition\"&gt;@transition/explode&lt;/item&gt; &lt;item name=\"android:windowReturnTransition\"&gt;@transition/explode&lt;/item&gt; &lt;item name=\"android:windowReenterTransition\"&gt;@transition/explode&lt;/item&gt; &lt;!-- 指定进入、退出、返回、重新进入时的共享transitions --&gt; &lt;item name=\"android:windowSharedElementEnterTransition\"&gt;@transition/change&lt;/item&gt; &lt;item name=\"android:windowSharedElementExitTransition\"&gt;@transition/change&lt;/item&gt; &lt;item name=\"android:windowSharedElementReturnTransition\"&gt;@transition/change&lt;/item&gt; &lt;item name=\"android:windowSharedElementReenterTransition\"&gt;@transition/change&lt;/item&gt; 也可以在activity的oncreate方法中进行代码设置：123456789101112// 允许使用transitionsgetWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);// 指定进入、退出、返回、重新进入时的transitionsgetWindow().setEnterTransition(new Explode());getWindow().setExitTransition(new Explode());getWindow().setEnterTransition(new Explode());getWindow().setExitTransition(new Explode());// 指定进入、退出、返回、重新进入时的共享transitionsgetWindow().setSharedElementEnterTransition(new ChangeTransform());getWindow().setSharedElementExitTransition(new ChangeTransform());getWindow().setSharedElementReturnTransition(new ChangeTransform());getWindow().setSharedElementReenterTransition(new ChangeTransform()); 普通转场动画所有继承自visibility类都可以作为进入、退出的过度动画。如果我们想自定义进入和退出时的动画效果，只需要继承Visibility，重载onAppear和onDisappear方法来定义进入喝退出的动画。系统提供了三种默认方式： explode 从屏幕中心移入或移出视图 slide 从屏幕边缘移入或移出视图 fade 改变视图的透明度想在xml中指定自定义的进入、退出的过度动画需要先对动画进行定义：1&lt;transition class=\"my.app.transition.CustomTransition\"/&gt; 注意：其中CustomTransition是你自定义的动画，它必须继承自Visibility。想以普通转场动画的方式启动一个Activity，必须在startActivity函数中传递一个ActivityOptions的Bundle对象：12ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity); startActivity(intent, options.toBundle()); 如果想让返回也具备转场效果，那么在返回的Activity中不要再调用finish函数，而是应该使用finishAfterTransition来结束一个Activity，该函数会等待动画执行完毕才结束该Activity。 共享转场动画当两个Activity具备某些相遇的元素时，共享转场动画将是一个非常好的选择。使用转场动画需要将相同的元素通过android:transitionName或者view.setTransitionName设置为相同的名称，这样系统才能区分出相同的元素。 共享转场动画支持以下共享元素： changeBounds 对目标视图的大小进行动画changeClipBounds 对目标视图的剪裁大小进行动画changeTransform 对目标视图进行缩放、旋转、位移动画changeImageTransform 对目标图片进行缩放通过下面的函数启动一个共享元素动画：12ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity, view, \"name\"); startActivity(intent, options.toBundle()); 如果有多个共享元素，则可以通过Pair进行包装处理：12ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity,Pair.create(view1, \"name1\"),Pair.create(view2, \"name2\")); startActivity(intent,.toBundle()); 返回时如果需要具备转场动画，那么也需要用finish函数替代finishAfterTransition来结束一个Activity。 共享转场动画通常可以根据指定的元素判断出合适的转场动画效果，不需要我们做额外的处理，也可以通过之前学习的方法进行指定共享元素转场动画效果。 组合转场动画我们可以把多个转场动画进行组合，作出更具个性的转场效果，在资源文件中通过以下方式：12345&lt;transitionSet xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;explode/&gt; &lt;transition class=\"my.app.transition.CustomTransition\"/&gt; &lt;&lt;changeImageTransform/&gt; &lt;/transitionSet&gt; 代码中我们可以通过TransitionSet类组合多个转场动画：123TransitionSet transitionSet = new TransitionSet();transitionSet.addTransition(new Fade());transitionSet.addTransition(new ChangeBounds()); 组合可以同时针对普通转场动画和共享元素转场动画。 转场动画也可以像普通动画一样设置持续时间，延期执行时间，速率插入器，以及动画的监听等。 转场动画通常是对整个布局起作用，如果我们想对某个特定的view实施转场动画，可以把该view设置为转场动画的target，这样转场动画将只对特定的view起作用。共享元素的动画的target需要指定为transitionName","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android动画","slug":"Android动画","date":"2016-11-25T09:20:52.000Z","updated":"2018-08-20T03:10:54.623Z","comments":true,"path":"2016/11/25/Android动画/","link":"","permalink":"https://zengwei123.github.io/2016/11/25/Android动画/","excerpt":"","text":"安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。 1.View动画 view动画的对象是View,他有四种动画效果，这四种效果都对应着四个类 平移-&lt;translate>-TranslateAnimation 缩放-&lt;scale>-ScaleAnimation 旋转-&lt;rotate>-RotateAnimation 透明-&lt;alpha>-AlphaAnimation 看下面的代码，就知道怎么使用了，set是一个动画集合，他会执行你所有定义了的动画，也就是说下面的这些动画会同时执行，这个文件创建在 /res/anim/xxx.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:fillAfter=\"true\" android:duration=\"500\"&gt; &lt;!-- android:fillAfter=\"true\" //这属性说明的的动画结束后是否停留在结束位置，true为停留，false为不停留 android:duration=\"500\" //这个是这组动画执行的事件 --&gt; &lt;!--平移动画--&gt; &lt;!-- android:fromXDelta=\"500\" //X的起始位置 android:fromYDelta=\"0\" //Y的其实位置 android:toXDelta=\"0\" //X的结束位置 android:toYDelta=\"0\" //Y的结束位置 --&gt; &lt;translate android:fromXDelta=\"500\" android:fromYDelta=\"0\" android:toXDelta=\"0\" android:toYDelta=\"0\" /&gt; &lt;!--缩放动画--&gt; &lt;!-- android:fromXScale=\"1.0\" //X的缩放起始值 android:fromYScale=\"1.0\" //Y的缩放其实值 android:toXScale=\"1.5\" //X的缩放结束值 android:toYScale=\"1.5\" //Y的缩放结束值 android:pivotX=\"100\" //缩放点的X轴 android:pivotY=\"50\" //缩放点的Y轴 --&gt; &lt;scale android:fromXScale=\"1.0\" android:fromYScale=\"1.0\" android:toXScale=\"1.5\" android:toYScale=\"1.5\" android:pivotX=\"100\" android:pivotY=\"50\" /&gt; &lt;!--旋转动画--&gt; &lt;!-- android:fromDegrees=\"50\" //旋转开始的角度 android:toDegrees=\"180\" //旋转结束的角度 android:pivotX=\"0\" //旋转的转轴X坐标 android:pivotY=\"0\" //旋转的转轴Y坐标 --&gt; &lt;rotate android:fromDegrees=\"50\" android:toDegrees=\"180\" android:pivotX=\"0\" android:pivotY=\"0\" /&gt; &lt;!--透明动画--&gt; &lt;!-- android:fromAlpha=\"1\" //起始透明 android:toAlpha=\"0.2\" //结束透明度 --&gt; &lt;alpha android:fromAlpha=\"1\" android:toAlpha=\"0.2\" /&gt;&lt;/set&gt; 那么如何使用这个动画呢？看下面 1234//获取你的动画Animation animation= AnimationUtils.loadAnimation(getApplicationContext(),R.anim.my);//使用你的动画button.startAnimation(animation); 不仅仅只能用xml的形式来使用动画，还可以用代码的方式，嗯，代码方式难得敲了，百度找吧 1.1 layoutAnimation我们有时候会看到一些列表有初始的进入动画，类似与下面这种，他使用的是LayoutAnimation,他的作用是给ViewGroup加上一个动画，这样它的子控件就都有这种效果了，使用这个东西首先你要定义一个layoutAnimation，这个文件创建在 /res/anim/xxx.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"10%\" android:animationOrder=\"normal\" android:animation=\"@anim/my\" //这个属性是你的动画 &gt;&lt;/layoutAnimation&gt; 然后在ViewGroup的 android:layoutAnimation=”@anim/layout” 加上你刚刚定义的layoutAnimation，这样子你的ViewGroup就都有出场动画了，但是有一点，在列表中的时候只有看的见的控件才有动画，看不见的是没有的，加载完成后你将它滑动显示，他是没有动画的，所以说你的动画要设计的要与这些没有动画的控件看起来协调。 1.2 Activity的切换效果主要是通过overridePendintTransition(int enterAnim,int exitAnim)这个方法,这个方法使用在startActivity(intent)，或者finish之后。enterAnim Activity打开时调用的动画资源exitAnim Activity被暂停调用的动画资源 2.帧动画 帧动画怎么说呢，就是一组图片，然后循环播放，它使用发放比较简单，但是比较容易引起内存泄露，所以使用帧动画应该避免过多的使用尺寸较大的图片xml文件的代码,duration代表的是每张图片的时间123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\"&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_01\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_02\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_03\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_04\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_05\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_06\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_07\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_08\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_09\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_10\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_11\" android:duration=\"100\"/&gt; &lt;item android:drawable=\"@drawable/ic_loading_white_12\" android:duration=\"100\"/&gt;&lt;/animation-list&gt; 然后使用它,这里是用AnimationDrawable123button.setBackgroundResource(R.drawable.zhen);AnimationDrawable animationDrawable= (AnimationDrawable) button.getBackground();animationDrawable.start(); 3.属性动画 3.1 ObjectAnimator 对于View动画我们只能够对其进行平移、旋转、透明，缩放进行操作，并且View动画进行改变之后，他是没有改变View的属性的，比如，你使用平移将控件平移100,但是你去出发他的点击事件，你会发现触发不了，点击原来的位置才能够出发，这就是View动画的局限性了，所以出来了属性动画，属性动画额能够对对象的属性进行操作，所以属性动画基本上是无所能的。 ObjiecAnimator的使用有一点很重要，就是在设置他的属性的时候必须要有set方法。因为有Set方法我们才能够对它进行属性的改变。 使用方法，123ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(button,\"translationX\", 0f,1000f);objectAnimator.setDuration(2000);objectAnimator.start(); 看到上面的代码是不是很简单呢，是的属性动画的使用方法非常简单，但是还是有一些其他的方法，来让我们更好的使用属性动画 12345objectAnimator.setEvaluator(new ArgbEvaluator()); //设置一个估值器，常用的有ArgbEvaluator\\IntEvaluator\\FloatEvaluatorobjectAnimator.setRepeatCount(-1); //动画的重复次数 -1代表无限重复objectAnimator.setRepeatMode(ObjectAnimator.REVERSE); //重复模式 REVERSE逆向重复 REPEAT 连续重复objectAnimator.setDuration(2000); //动画持续时间objectAnimator.setStartOffset(2000); //延迟时间 下面列举一些常用的属性动画 12345678910111213141516171819ObjectAnimator.ofInt(button,\"backgroundColor\", Color.RED,Color.YELLOW,Color.BLUE); //背景颜色的改变ObjectAnimator.ofInt(button,\"textColor\", Color.RED,Color.YELLOW,Color.BLUE); //字体颜色的改变ObjectAnimator.ofFloat(button,\"textSize\", 15f,30f); //字体大小ObjectAnimator.ofFloat(button,\"translationX\", 0f,1000f); //X（左右）轴平移ObjectAnimator.ofFloat(button,\"translationY\", 0f,1000f); //Y（上下）轴平移ObjectAnimator.ofFloat(button,\"translationZ\", 0f,1000f); //Z（高度）轴平移//这里是旋转这里注意一下他可以设置旋转的轴心，原本旋转是控件的中心，你可以通过下面两个方法来设置轴心button.setPivotX(0);button.setPivotY(0);ObjectAnimator.ofFloat(button,\"rotationX\", 0f,1000f); //沿X旋转ObjectAnimator.ofFloat(button,\"rotationY\", 0f,1000f); //沿Y旋转ObjectAnimator.ofFloat(button,\"rotation\", 0f,1000f); //平面旋转//缩放动画ObjectAnimator.ofFloat(button,\"scaleY\", 1f,2F); ObjectAnimator.ofFloat(button,\"scaleX\", 1f,2F);ObjectAnimator.ofFloat(button,\"textScaleX\", 1f,2F); //这个是字体的缩放ObjectAnimator.ofFloat(button,\"alpha\", 1f,0.2F); //透明度 3.2 ValueAnimator ValueAnimator动画是ObjeecAnimator的父类，ObjeecAnimator的实现就是基于Value的，但是这两个类有什么区别呢？ObjeecAnimator主要是对属性的过渡操作，而Value则是对值的过渡操作。 下面给一个ValueAnimator的例子，它实现了对Button的text的改变，还有对字体大小，宽度的改变，具体的可以看看注释。 1234567891011121314151617181920button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; ValueAnimator valueAnimator=ValueAnimator.ofInt(1,100); //一个区间 valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; IntEvaluator intEvaluator=new IntEvaluator(); //一个估值器 @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; //动画过程的监听方法 int i= (int) valueAnimator.getAnimatedValue(); //获取动画当前的值 float f=valueAnimator.getAnimatedFraction(); //获取当前整个动画所占比例 button.getLayoutParams().width=intEvaluator.evaluate(f,0,600); //按照当前比例计算出所占的值 f-比例 0-初始值 600-结束值 button.setTextSize(i); //设置字体大小 button.setText(i+\"\"); //设置值 button.requestLayout(); //当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view重新调用他的onMeasure onLayout来对重新设置自己位置。 &#125; &#125;); valueAnimator.setDuration(3000).start(); //设置过渡时间 启动 &#125; &#125;); ValueAnimator不仅仅可以作用在改变控件上面，更多的是去改变对象的值。 3.3 AnimatorSet 这是一个动画的集合，能够同时做出集中不同的动画,看下面的例子 12345play(Animator anim)：添加一个动画，并返回AnimatorSet.Builder playSequentially(List items)：添加一组动画，播放顺序为一一播放 playSequentially(Animator… items)：添加一组动画，播放顺序为一一播放 playTogether(Collection items)：添加一组动画，播放顺序为一起播放 playTogether(Animator… items)：添加一组动画，播放顺序为一起播放 很有意思。。 最后看看需要注意的问题：","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"github制作远程依赖库","slug":"github制作远程依赖库","date":"2016-11-17T09:58:13.000Z","updated":"2018-08-18T09:27:10.275Z","comments":true,"path":"2016/11/17/github制作远程依赖库/","link":"","permalink":"https://zengwei123.github.io/2016/11/17/github制作远程依赖库/","excerpt":"","text":"今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法首先先创建一个库工程，注意这个库工程是建立在项目里面的然后配置这里将zengwei123改成你的github用户名apply plugin: ‘com.github.dcendents.android-maven’group=’com.github.zengwei123’classpath ‘com.github.dcendents:android-maven-gradle-plugin:2.1’然后将你的项目上传github,上传之后点击然后输入信息然后发布 ；发布之后，打开网址 https://jitpack.io/在下面的输入框中输入你的仓库的url：如https://github.com/zengwei123/Curve如果你配置错了，那么就不是绿色的Get it。滑到下面，会有一个这个如果你一直是这一个样子的，那么就说明没有配置成功，他应该是：com.github.你的用户名:项目名:版本号，最后成功了，就可以在其他项目使用依赖的方式使用你的项目了","categories":[{"name":"GitHub-Git","slug":"GitHub-Git","permalink":"https://zengwei123.github.io/categories/GitHub-Git/"}],"tags":[]},{"title":"Android-事件分发机制","slug":"Android-事件分发机制","date":"2016-11-05T02:28:00.000Z","updated":"2018-08-14T07:47:55.037Z","comments":true,"path":"2016/11/05/Android-事件分发机制/","link":"","permalink":"https://zengwei123.github.io/2016/11/05/Android-事件分发机制/","excerpt":"","text":"事件分发主要分为2部分，View分发与ViewGroup，在了解事件分发的之前首先了解一下View与ViewGroup,View是没有子控件的，如Button,TextView等，但是ViewGroup是有子控件的，如ViewPager,RelativeLayout。 首先看看View的事件分发，主要是两个方法dispatchTouchEvent和OnTouchEvent，从流程是从Activity-View，Activity的dispatchTouchEvent是事件分发的第一入口。我们继承一个Button重写他的dispatchTouchEvent和OnTouchEvent调用button的setOnTouchListener和setOnClickListener重写activity的dispatchTouchEvent和OnTouchEvent点击button,我们会看到下面这个Log打印顺序 在这里你可能会奇怪为什么Activity的OnTouchEvent为什么没有调用，这是因为我们的Button在OnTouchEvent中已经处理了事件，最后执行的click，当我们将Button的OnTouchEvent返回值改为false,我们会看到下面的这中情况。这时候Activity的OnTouchEvent就被调用了，因为我们在button的OnTouchEvent不处理事件，这样最后没人处理我们只能将事件返回给Activity，这样Activity的OnTouchEvent就会被调用 这里我们看到最后没有执行click事件，并且UP也没有执行了，这是因为button在Down后没有处理事件，最后到了activity那里处理如果我们在up的时候不处理，返回一个false这样我们的Down和Up都执行但是最后的click没有执行，因为button没有处理事件，所以事件最后就到了Activity哪里，执行了OnTouchEvent最后看书： 下面来说说ViewGroup的分发事件，其实原理跟View差不多，只不过它多了一个onInterceptTouchEvent这个方法是用来控制事件是给自己消费还是分发给子控件。 1.默认的onInterceptTouchEvent总是返回false的，就是不拦截touch事件，直接分发给了子控件。所以假如我们自定义了组合控件，譬如image+文字的组合控件，并且在activity里面注册监听期待点击它的时候会产生响应，那么我们就需要重写onInterceptTouchEvent了让它返回true，将事件拦截下来。 2.如果触摸的时候，我们只想出发ontouch监听，想屏蔽onclick监听的话，就需要在ontouch里面返回true就可以了 3.android事件分发是先传递到viewgroup，然后才传递到view的 4.子view如果将传递的事件消费处理掉，viewgroup当中是接收不到任何事件的 5.简单来讲，dispatchTouchEvent方法是为了onTouch监听的，onTouchEvent是为了onClick监听的。如果ontouch监听返回false，事件会传递到onTouchEvent当中触发onClick，如果是true的话就不会继续往下传递了。","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android常用控件-ViewPage","slug":"Android常用控件-ViewPage","date":"2016-10-29T10:07:03.000Z","updated":"2018-08-13T11:52:00.909Z","comments":true,"path":"2016/10/29/Android常用控件-ViewPage/","link":"","permalink":"https://zengwei123.github.io/2016/10/29/Android常用控件-ViewPage/","excerpt":"","text":"ViewPage是我们非常常用的控件，他的功能就是多视图的切换 ViewPage · ViewPage他继承了ViewGroup,所以他是一个容器类，可以在其中添加其他的View。 · ViewPage需要一个Adatper来给他提供数据 · ViewPage经常与Fragment和TabLayout一起使用 使用ViewPage+TabLayout首先看看布局,这个就是一个最基本的ViewPage+TabLayout的布局了，可能TabLayout需要额外导入compile ‘com.android.support:design:26.1.0’ 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.TabLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/tabLayout&quot;&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewpager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@+id/tabLayout&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/RelativeLayout&gt; 然后看看Fragment的代码，很简单的1234567public class MyFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View view=inflater.inflate(R.layout.activity_main,null); return view; &#125;&#125; 然后编写ViewPage的适配器，注意重写getPageTitle(int position)这个方法是用来设置TabLayout的title的，因为TabLayout是跟ViewPager绑定起来的12345678910111213141516171819202122public class myViewPageAdatper extends FragmentPagerAdapter &#123; private List&lt;MyFragment&gt; myFragments; public myViewPageAdatper(FragmentManager fm, List&lt;MyFragment&gt; fragments) &#123; super(fm); this.myFragments=fragments; &#125; @Override public Fragment getItem(int position) &#123; return myFragments.get(position); &#125; @Override public int getCount() &#123; return myFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return \"标题：\"+position; &#125;&#125; 下面是ViewPage的设置最后的效果对于ViewPage我们的程序有各种各样的需求，有时候我们需要他不能够滑动这是我们可以设置setOnTouchListener()返回值为true，根据事件分发机制，在onTouch中的DOWN事件时候，将事件拦截。123456viewpager.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; return true; &#125; &#125;); 这样子是可以实现，但是如果ViewPager的Fragment里面有可以滑动的控件，比如又一个ViewPager,这样我们上面的那种办法就没有用了viewPager还是可以被拖出来，对于这种情况我们只有继承ViewPager来重新分发它的事件，禁止它的滑动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ZwViewPage extends ViewPager &#123; private boolean isScroll; public ZwViewPage(Context context) &#123; super(context); &#125; public ZwViewPage(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; /** * 1.dispatchTouchEvent一般情况不做处理 *,如果修改了默认的返回值,子孩子都无法收到事件 */ @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; return super.dispatchTouchEvent(ev); // return true;不行 &#125; /** * 是否拦截 * 拦截:会走到自己的onTouchEvent方法里面来 * 不拦截:事件传递给子孩子 */ @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; // return false;//可行,不拦截事件, // return true;//不行,孩子无法处理事件 //return super.onInterceptTouchEvent(ev);//不行,会有细微移动 if (isScroll)&#123; return super.onInterceptTouchEvent(ev); &#125;else&#123; return false; &#125; &#125; /** * 是否消费事件 * 消费:事件就结束 * 不消费:往父控件传 */ @Override public boolean onTouchEvent(MotionEvent ev) &#123; //return false;// 可行,不消费,传给父控件 //return true;// 可行,消费,拦截事件 //super.onTouchEvent(ev); //不行, //虽然onInterceptTouchEvent中拦截了, //但是如果viewpage里面子控件不是viewgroup,还是会调用这个方法. if (isScroll)&#123; return super.onTouchEvent(ev); &#125;else &#123; return true;// 可行,消费,拦截事件 &#125; &#125; public void setScroll(boolean scroll) &#123; isScroll = scroll; &#125;&#125; 这样子我们就实现了禁止ViewPager的滑动，下面我们来说说ViewPager的预加载。ViewPager会默认加载当前页和当前页的左右两页。一开始当前页是下标0，所以一开始默认加载第0页（指下标，下同）和第1页。当你向右滑动，当前页为第1页时，ViewPager会加载第2页，这时一共有3页存在（第0,1,2页）。再向右滑动，当前页为第2页时，会移除第0页，加载第3页，同理向左滑动当前页为第1页时，会移除第3页。我们可以设置下面的这个方法来预加载多个页面。1viewpager.setOffscreenPageLimit(int i); 但是如果我们不想要他预加呢？当每个fragment都需要去联网加载网络数据或者做一些耗时的操作，而且有其他的fragment并不是必须的，用户不一定会打开。这样的话如果还预加载的话将会浪费资源，用户体验也不好。虽然可以通过setOffscreenPageLimit(0)来设置不提前预加载，但这样的设置没有效果。通过研究ViewPager的源码，可以设置该类默认的DEFAULT_OFFSCREEN_PAGES = 0，来预防预加载。还有一直办法就是判断fragment的位置是否为当前显示ViewPager，如果是就加载，不是的话就不给加载设置ViewPager默认显示的页面,通过这个方法就可以通过代码设置页面的切换了1ViewPager.setCurrentItem(2) 如果想要下面这种效果在布局文件中色湖之ClipToPadding=“false”然后设置padding,就可以实现了","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android随笔-Fragment","slug":"Android-Fragment","date":"2016-10-18T08:09:07.000Z","updated":"2018-08-13T06:55:18.036Z","comments":true,"path":"2016/10/18/Android-Fragment/","link":"","permalink":"https://zengwei123.github.io/2016/10/18/Android-Fragment/","excerpt":"","text":"一.Fragment简介：Android在3.0中引入了Fragments的概念，主要目的是用在大屏幕设备上–例如平板电脑上，支持更加动态和灵活的UI设计。平板电脑的屏幕要比手机的大得多，有更多的空间来放更多的UI组件,并且这些组件之间会产生更多的交互。Fragment允许这样的一种设计，而不需要你亲自来管理View Hierarchy的复杂变化。通过将Activity的布局分散到Fragment中，你可以在运行时修改Activity的外观，并在由Activity管理的Back Stack中保存那些变化。 其实这只是比较官方一点的说法,其实通俗易懂点说就是,一个可以将activity拆分成几个完全独立封装的可重用的组件，每个组件有自己的生命周期和ui布局。它可以表示Activity中的行为或用户界面部分。我们可以在一个Activity中用多个Fragment组合来构建多窗格的UI，以及在多个Activity中重复使用某个Fragment。它有自己的生命周期，能接受自己的输入，并且可以在 Activity 运行时添加或删除Fragment（有点像在不同 Activity 中重复使用的“子 Activity”）。 二.Fragment生命周期： onAttach() : Fragment和Activity建立关联的时候调用，被附加到Activity中去。 onCreate() : 系统会在创建Fragment时调用此方法。可以初始化一段资源文件等等。 onCreateView() : 系统会在Fragment首次绘制其用户界面时调用此方法。要想为Fragment绘制UI，从该方法中返回的View必须是Fragment布局的根视图。如果Fragment未提供UI，您可以返回null。 onViewCreated() : 在Fragment被绘制后，调用此方法，可以初始化控件资源。 onActivityCreated() : 当onCreate onCreateView()，onViewCreated()方法执行完后调用，也就是Activity被渲染绘制出来后。 onStart() : 当系统调用该方法的时候，fragment已经显示在ui上，但还不能进行互动，因为onResume方法还没执行完。 onResume() : 该方法为fragment从创建到显示Android系统调用的最后一个生命周期方法，调用完该方法时候，fragment就可以与用户互动了。 onPause() : 系统将此方法作为用户离开Fragment的第一个信号（但并不总是意味着此Fragment会被销毁）进行调用。 通常可以在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。 onStop() : 当onStop返回的时候，fragment将从屏幕上消失。 onDestoryView() : 该方法的调用意味着在 onCreateView 中创建的视图都将被移除。 onDestroy() : Android在Fragment不再使用时会调用该方法，要注意的是这时Fragment还和Activity相关联的！并且可以获得Fragment对象，但无法对获得的Fragment进行任何操作。 onDetach() : 为Fragment生命周期中的最后一个方法，当该方法执行完后，Fragment与Activity不再有关联。 顺序如图下： 三.Fragment与Activity关系：总的来说，Fragment和Activity的生命周期类似。需要注意的是，它相比于Activity，多了onAttach(), onCreateView(), onActivityCreate)和onDestoryView()、onDetach()这几个回调函数；但是，却少了onRestart()。 onAttach(Activity) : 当Fragment和Activity发生关联时使用 onCreateView(LayoutInflater, ViewGroup, Bundle) : 创建该Fragment的视图 onActivityCreate(Bundle) : 当Activity的onCreate方法返回时调用 onDestoryView() : 与onCreateView相对应，当该Fragment的视图被移除时调用 onDetach() : 与onAttach相对应，当Fragment与Activity关联被取消时调用 关系图如下：注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现。 四.总结：在用法的代码部分参考郭神的博客，感觉郭神在代码讲解部分通俗易懂，看起来也方便。总之，在使用Fragment也有一些注意事项，不是那么完美的，虽然谷歌推荐我们用Fragment来代替Activity来使用，我们也确实这做了，现在基本主流的APP也都是少量Activity+很多Fragment，但也需要避免有些坑慎入。","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android消息机制-Handler","slug":"Android消息机制-Handler","date":"2016-10-13T06:53:50.000Z","updated":"2018-08-13T10:24:03.406Z","comments":true,"path":"2016/10/13/Android消息机制-Handler/","link":"","permalink":"https://zengwei123.github.io/2016/10/13/Android消息机制-Handler/","excerpt":"","text":"安卓中的消息机制说的其实就不同线程间的通讯，就是Handler。 为什么安卓中要有消息机制？ 因为在安卓中更新UI是必须在子线程中，UI控件部署线程安全的，如果多线程并发访问就会出现问题。 你可能要问为什么不给UI控件加上锁呢？ 这是因为上锁之后会让UI变得复杂同时效率变低，还会阻塞某些进程的执行，所以UI采用单线程模式，这对开发者也不是很麻烦，只要通过Handler就能够解决。 下面就是Handler的基本用法，在子线程中跟新UI 这个就是Handler的基本用法。 消息机制的分析 安卓的消息机制就是Handler机制，在handler机制中有两个很重要的东西，一个是Looper、另一个是MessageQueue,这两个东西和Handler凑成了Android中的非常重要的消息机制。 他的原理是这样的： 1、Handler创建一个消息，将这个消息插入到MessageQueue中。 2、Looper不断轮询MessageQueue的next方法。 3、Looper发现有消息（Message）了,就调用回调方法handlerMessage。 我们常常用Handler来进行更新UI但是这并不是说它只能够跟新UI，如同读取文件，网络请求等耗时操作都可以在Handler里面来进行的。通过上面的原理我们了解需要有一个消息队列MessageQueue，那么这个消息队列是从哪里来的呢？这里我们就要看到Looper，这个类的构造方法中创建了MessageQueue,然后将当前线程的对象保存起来。 而我们的Handler的创建也不能离开Looper,如果new一个Handler但是他没有Looper的话就会报错，可能你这里你就有疑问了，我们在上面的更新UI的实例中并没有看到哪里有Looper,这是因为我们的UI线程在创建的时候就会创建一个Looper,当我们如果在子线程new一个Handle就会出现保存，所以我们要主动去创建一个Lopper。 Lopper的几个方法 1、Looper.prepare():为当前线程创建一个Looper 2、Looper.loop():开启消息轮询 3、Looper.myLooper.quit():直接退出Looper 4、Looper.myLooper.quitSafely():设定一个标记，只有当目前已有的消息处理完才会执行退出操作。 当Looper退出之后，Handler就无法发送消息，当Looper退出后，Handler就无法发送消息，send出去的消息会返回false；当我们在子线程中创建了Looper并且所有的消息都处理完毕的时候，要记得调用quit方法，不让这个Looper就一直处于阻塞状态一直那么等待下去，同时主线程的Looper是无法退出的。 我们看看Looper的loop()方法的源码 通过代码我们知道：looper方法是一个死循环，唯一跳出的循环的方式是MessageQueue的next方法返回null，但是基本上是不可能的。如果我们不手动调用quit或者quitSafely方法的话，MessageQueue的next方法是不可能返回null的。因为当MessageQueue没有消息时，next方法会一直阻塞在那里，因为MessageQueue的next方法阻塞了，就导致Looper的loop方法也一直在阻塞了。这里我们那一分为二的谈，loop轮询不到消息：那么处于阻塞状态，然后就没有然后了，除了又轮询到了新的消息loop轮到了新的消息：Looper就会处理消息1、msg.target.dispatchMessage(msg)，这里的 msg.targe就是指Handler对象2、一圈下来，Handler发送的消息有交给了自己的dispatchMessage方法来处理了。（这个dispatchMessage方法不是Handler自己调用时，是与Handler相相关的Looper简介调用的），这样下来，就成功地将逻辑切换到指定的线程当中去了 Handler的主要工作就是接受和发送 下面是发送的方法，主要有两种post,send; 而我们接收的方法：dispatchMessage方法dispatchMessage会判断三种情况 1、如果是post发送来的message，那么就让这个message所持有的Runnable执行run方法，非常简单。Message的Callback 是一个Runnable对象，Handler的post的重载的函数不管参数多少，肯定都是有Runnable的。 private static void handleCallback(Message message) { message.callback.run(); } 2、如果是利用Handler(Callback callback) 构造函数实例化的Handler，也就是构造函数里面传入了一个CallBack的对象，那么就执行这个Callback的handlerMessage。利用这个接口和Handler的一个构造函数，我们可以这么创建Handler handler=new Handler(callback)来创建Handler;备注写明了这个接口的作用：可以创建一个Handler的实例但是不需要派生Handler的子类。对比我们日常中最经常做的，就是派生一个Handler的子类，复写handleMessage方法，而通过上面的代码，我们有了一种新的创建Handler方式，那就是不派生子类，而是通过Callback来实现。 这种方式非常少用。 看一下Handler里面的Callback这个接口的设计123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 3、如果是send方法发送的，那么就执行handleMessage，这个方法我们非常熟悉了，google的给的备注的也说了，子类必须实现方法以接受这些Message。这也就是我们最常见的最常用的方式了。 /** * Subclasses must implement this to receive messages. */ public void handleMessage(Message msg) { } 参考：https://www.jianshu.com/p/9e4d1fab0f36","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android-如何在子线程中更新UI","slug":"Android如何在子线程中更新UI","date":"2016-10-07T01:27:16.000Z","updated":"2018-08-13T08:46:36.016Z","comments":true,"path":"2016/10/07/Android如何在子线程中更新UI/","link":"","permalink":"https://zengwei123.github.io/2016/10/07/Android如何在子线程中更新UI/","excerpt":"","text":"一.前言：项目开发中会涉及到一些耗时操作，这个时候就会开启一个子线程，将耗时操作放到子线程中取操作，操作完毕后，往往还要同步更新ui，这个时候如果直接在子线程中更新ui，将会导致程序的闪退，同时还会看到如下报错 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.意思是：只有创建视图层次结构的原始线程才能触及它的视图，其实说白了就是在子线程不能做更新UI的操作。 二.解决方法： 第一种方式 : runOnUiThread 第二种方式 : view.post(); 第三种方式 : Handler.post(); 第一种方式 : runOnUiThread 第二种方式 : view.post(); 第三种方式 : Handler.post();","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android侧滑布局-DrawerLayout","slug":"Android侧滑布局-DrawerLayout","date":"2016-09-26T03:54:14.000Z","updated":"2018-08-07T07:42:27.676Z","comments":true,"path":"2016/09/26/Android侧滑布局-DrawerLayout/","link":"","permalink":"https://zengwei123.github.io/2016/09/26/Android侧滑布局-DrawerLayout/","excerpt":"","text":"DrawerLayout是谷歌官方推出的侧滑菜单,DrawerLayout最好为界面的根布局，否则可能会出现触摸事件被屏蔽的问题；主内容区的布局代码要放在侧滑菜单布局的前面, 因为 XML 顺序意味着按 z序（层叠顺序）排序，并且抽屉式导航栏必须位于内容顶部；侧滑菜单部分的布局必须设置layout_gravity属性，他表示侧滑菜单是在左边还是右边，而且如果不设置在的时候会报错，设置了layout_gravity=”start/left”的视图才会被认为是侧滑菜单,同时侧滑的布局必须放在最下面，不然无法响应侧滑控件的的事件，只会点击之后就关闭侧滑drawerLayout左侧菜单（或者右侧）的展开与隐藏可以被DrawerLayout.DrawerListener的实现监听我们还可以通过按钮显示侧边栏侧滑的布局可以写在fragment,这里name属性就是用来对应的Fragment的经过这几步我们就吧侧滑菜单写出来了在这里 drawer_layout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.END); 锁定右面的侧滑菜单，不能通过手势关闭或者打开，只能通过代码打开！如果DrawerLayout侧滑菜单中的控件点击事件能穿透到底部,那么可以在菜单的布局文件中设置clickable=&quot;true&quot;如果想实现QQ那种底部布局跟则动的效果就在addDrawerListener事件中的onDrawerSlide()添加下面的代码,就能跟随移动了 //mDrawerLayout为你的DrawerLayout View content = mDrawerLayout.getChildAt(0); int offset = (int) (drawerView.getWidth() * slideOffset); content.setTranslationX(offset);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android四大组件之Service","slug":"Android四大组件之Service","date":"2016-09-19T02:58:12.000Z","updated":"2018-08-07T03:38:39.593Z","comments":true,"path":"2016/09/19/Android四大组件之Service/","link":"","permalink":"https://zengwei123.github.io/2016/09/19/Android四大组件之Service/","excerpt":"","text":"1.Service作用： 提供需要长期在后台长期运行的服务（如复杂计算、下载等），主要是因为它没有长的生命周期、没有用户界面、在后台运行。 2.Service分类： 本地：运行在主线程，主线程终止后服务也会终止。但是能够节约资源，并且通信方便，由于在同一进程不需要IPC和AIDL，主要使用在需要依附某个进程的服务，音乐播放等。远程：运行在独立进程，常驻在后台，不受其他Activity影响但是非常消耗资源，通讯需要比较复杂，主要使用在系统级别的服务。前台：通知栏可以显示出来，用户可以看到，主要使用在需要让用户只要并进行相关操作，如音乐播放。后台：主要是用户无法看到，主要使用在不需要让用户知道的一些操作，跟新数据，同步数据等 3.生命周期 · 如果Service是第一次启动先会执行 onCreate(),onStartCommand()· 当次启动Service调用，将只执行onStartCommand()，因为此时Service已经创建了，无需执行onCreate()回调。无论多少次的启动Service，只需要一次stopService()即可将此Service终止，执行onDestroy()函数。· onStartCommand(..)可以多次被调用，onDestroy()与onCreate()相匹配，当用户强制kill掉进程时，onDestroy()是不会执行的。· startService(Intent serviceIntent)，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。· 当Service需要运行在单独的进程中，AndroidManifest.xml声明时需要通过android:process指明此进程名称，当此Service需要对其他App开放时，android:exported属性值需要设置为true. 4.通讯 简单通信直接通过Intent进行传值，我们在启动一个Service的时候通过Intent的对象向Service进行传值，这种方式传递值比较不方便，性能不是很高。传值：获取值： 2．绑定服务传输数据 在Service中编写Binder的内部类，自定义方法进行数据传输。活动类：服务类： 通过使用Messenger方式（可以在不同进程间通讯）服务端：客户端 5.服务单独运行在进程 在XML文件中给Service添加process属性，有两种赋值方式，一种是[:xxxxx],一种是[com.pw.xxx.xxx] 第一种赋值是一种简写，完整的写法是[com.xxx.xxx:xxxx]这样的进程是应用的私有进程，其他应用不会跟它跑到同一个地方去。而第二种就是一种全局进程，其他的应用程序可以通过ShareUID跑进去。多进程的使用地方，可以使用在一些需要保活的地方，音乐后台播放，在退出activity后还能继续播放、加载大图、推送服务，能够在程序退出后继续的向用户推送东西。将功能独立的分开来，减少程序崩溃","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Android四大组件之Activity","slug":"Android四大组件之Activity","date":"2016-09-15T01:09:23.000Z","updated":"2018-08-07T02:59:42.064Z","comments":true,"path":"2016/09/15/Android四大组件之Activity/","link":"","permalink":"https://zengwei123.github.io/2016/09/15/Android四大组件之Activity/","excerpt":"","text":"1.正常的周期 OnCreate: 生命周期的第一个方法，可以做一些初始化的操作onRestart: 表示activit正在重新启动，这一般是当activity从不可见变成可见时调用，一般是由用户行为导致OnStart:这是说明activity正在被启动，即将开始。OnResume:表示activity已经可以看见了，并且出现在前台，已经与用户进行交互了。在这里OnStart和OnResume都是出现已经可见了，但是OnStart还在后台而OnResume已经出现在了前台OnPause:表示activity正在停止，这个时候OnStop马上回被调用，在这里已经进行一些数据存储，动画显示等不耗时的操作，因为OnPause要执行完才能执行其他activity的OnResume。OnStop:表示activity即将停止，在这里可以做一些资源比较有重量的回收，但是也不能太过耗时。OnDestroy:最后一个方法，表示activity活到头了，在这里可以做一些回收工作和资源释放 OnStart和OnResume、OnPause和OnStop这两对方法没有什么实质性的不同，OnResume是可见周期的最后一个方法已经结束了，OnStart是还正在启动，OnPauses要执行完之后才能执行新activity的方法，OnStop是结束周期中简的一个 2.异常的生命周期 1、资源相关的系统配置发生改变导致activity被杀死重建竖屏时变成横屏，由于设置了不同资源图片，activity会销毁重建。他会执行onPause→onSaveInstanceState→onStop→onDestroy然后onCreate→onStart→onResumeonSaceInstanceState是在异常结束activity时才会执行的方法，他会保存当前activity的状态同时会在新创建的activity调用onRestoreInstanceState方法并且将onSaceInstanceState方法保存的bundle传递给onCreate。我们可以在onSaceInstanceState中存储一些数据，在onRestoreInstanceState或者onCreate中读取，有一点onRestoreInstanceState如果执行那么Bundle是不会为空的，但是onCreate中就不知道了 2、资源不足导致优先级低的activity被杀死优先级：前台activity 可见非前台activit（比如弹出一个对话框） 后台activit杀死activity后，就会在有内存的时候通过onSaceInstanceState 保存onRestoreInstanceState恢复可以通过设置android：configChanges=”orientation” 静止重建 3.Activity启动模式 1、存在的意义：多次启动同一个activity，多次创建同一个实例，这是很傻的行为1.standard（默认）每次启动activity都会重新创建实例2.singleTop（栈顶复用模式） 判断activity是否在任务栈顶，如果在直接引用，同时调用onNewIntent方法，如果不在就创建新的实例。3.singleTask（栈内复用模式） 判断栈中是否有这个实例，如果有那么就使用这个实例，如果没有那么就创建一个，这个activity会调用onNewIntent4.singleInstance（单实例模式）这个是 singleTask 模式的加强版，它除了具有 singleTask 模式的所有特性外，它还有一点独特的特性，那就是此模式的 Activity 只能单独地位于一个任务栈，不与其他 Activity 共存于同一个任务栈。 2、什么是任务栈：这是一个activity的参数TaskAffinity,这个参数标识了activity所需要的任务栈，默认情况下任务栈的名字为包名，我们可以给每个activity命一个名字，同名的是名字就是在一个任务栈，它主要是和singleTask或者allowTaskReparenting结合使用。在TaskAffinity和allowTaskRepaernting一起使用且allowTaskRepaernting为true的时候如果当一个应用A的activity启动了一个应用B的activity，那么这个B应用的activity会直接从A的任务栈跑到B的任务栈。当返回桌面，点击应用B，他不会启动住activity，而会显示应用A启动的acitivity 设置启动模式有两种方法：1.通过launchMode指定2.通过Intent.addFlage指定第二种的优先级比第一种要高，第二种无法指定为第四种模式 3、Activity隐式调用隐式调用能够设置一些过滤信息，如果不匹配将无法启动activity。需要匹配：action、category、dataAction：是一个字符串，这里指定匹配是字符串相同，在xml文件中如过指定了action，如果在intent中没有设置，那么是无法匹配成功的，想要匹配必须intent中的字符串与action的字符串相同。Category：Category中必须要有一个android.intent.Category.DEFAULT,而且intent可以不指定Category。Date:规则跟action一样，如果定义了那么就要指定，Date主要是一个规则，用来放置url 我们还可以在配置文件的activity中设置android:screenOrientation属性来设置他的横竖屏显示portrait（竖屏），landscape （横屏） 全屏的 Activity要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现： // 设置全屏模式 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); 4.使用 Intent 通信 在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。 在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。 如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去： Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容 bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容 bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity 那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息： Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容 bundle.getString(&quot;string_key&quot;); 上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法： Intent intent =new Intent(EX06.this,OtherActivity.class); intent.putExtra(&quot;boolean_key&quot;, true); intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;); startActivity(intent); 接收： Intent intent=getIntent(); intent.getBooleanExtra(&quot;boolean_key&quot;,false); intent.getStringExtra(&quot;string_key&quot;);","categories":[{"name":"Android","slug":"Android","permalink":"https://zengwei123.github.io/categories/Android/"}],"tags":[]},{"title":"Hexo常用命令","slug":"hexo常用命令","date":"2016-09-04T08:25:04.000Z","updated":"2018-08-06T02:57:06.613Z","comments":true,"path":"2016/09/04/hexo常用命令/","link":"","permalink":"https://zengwei123.github.io/2016/09/04/hexo常用命令/","excerpt":"","text":"1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog $ hexo init [folder] 2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致 · post&nbsp;&nbsp;我一般都用post，默认就是这个 · page · draft $ hexo new [layout] 文章建立之后，在你的网站文件夹中 \\source\\_posts 路径下面可以找到创建的文章文件，是 markdown 格式的，文件后缀名为 .md, Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量,以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 · layout 布局 · title 标题 · date 建立日期 · updated 更新日期 · comments 开启文章的评论功能 · tags 标签 · categories 分类 · permalink 覆盖文章网址3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了 $ hexo g -d 4.启动本地服务,可以在写完文章后查看效果 $ hexo s 5.有时候博客写完，上传giehub无效果，那么试试清除缓存 $ hexo clean 基本的hexo编写博客的使用就到这里了，使用上面几条命令就能够创建编写上传你的文章到博客去。其他的一些操作可以去hexo官网查看官方文档HEXO官方文档","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]},{"title":"Hexo搭建博客","slug":"hexo搭建博客","date":"2016-09-02T15:15:04.000Z","updated":"2018-08-06T07:16:01.561Z","comments":true,"path":"2016/09/02/hexo搭建博客/","link":"","permalink":"https://zengwei123.github.io/2016/09/02/hexo搭建博客/","excerpt":"","text":"花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！ Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致配置不一样，我是windows所有 1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的 安装git、node.js，首先官网去下载安装包，如果是mac一行命令的事情，然后一直下一步下一步下一步就ok,没有什么其他的出问题百度吧，这里就不多说了，下面贴上两个东西的下载地址Git下找地址Node.js下找地址 2.安装Hexo 安装好Git后，桌面右击会增加两个东西 Git GUI here 、Git Bash here 这两个东西，点击Bash,就进入了Git的终端命令的界面了，你就可以快乐的敲命令了，输入 npm install -g hexo-cli刷刷刷，然后Hexo就安装好了，你就可以搭建你的博客了 3.建站 首先先创建你的网站，在git命令终端用下面这个命令 hexo init folderfolder可以自己随意命名，也可以随意指定路径，然后等待一会就把网站给你创建好了，在创建的命令信息中你可以看到自己创建的网站路径，记住这个路径，然后你可以输入hexo s这个命令启动服务来本地运行网站，浏览器输入：127.0.0.1:4000 就能够看到Hexo默认的主题我网站，这样我们就已经建好站了 4.配置到Github 首先在github上面创建一个仓库名字叫做：用户名.github.io,注意用户名一定要跟自己的github账户相同创建仓库创建好仓库之后拿到他的ssh地址或者Https地址这样我们就吧hexo对应的github仓库建立好了，然后来到博客根路径下，打开_config.yml这个文件夹找到下面这一段，将repository的内容替换成你自己刚刚拿到的ssh或HTTPs地址然后在再到下面这段，将里面的url换成你自己的：用户名.github.io(注意：这个url就是你以后博客的地址)到这里我们基本上就跟github关联起来了，但是为了以后更加方便，我们配置一下SSH 5.配置SSH 首先，终端中输入cd ~/.ssh 查看有没有SSH如果有就删除吧，然后输入ssh-keygen -t rsa -C “你的邮箱”，后面会要你输入密码，这个不用管，一直回车，最后如果出现下面这个图的样子，就是成功了然后到类似于：C:\\Users\\13085.ssh这种的目录下找到一个叫id_rsa.pub的文件，打开将里面的东西全部复制，进入GitHub到这里，SSH就全部配置完了 6.上传网站 输入命令hexo g，此时若出现如下报错：ERROR Local hexo not found in ~/blogERROR Try runing: ‘npm install hexo –save’则执行命令：npm install hexo –save若无报错，自行忽略此步骤。 然后输入hexo d,若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：npm install hexo-deployer-git –save 7.查看网站 打开浏览器输入：https://你的用户名.github.io，就能够看到你的网站了，跟前面本地看到的效果是一样的","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://zengwei123.github.io/categories/Hexo/"}],"tags":[]}]}