<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zengwei</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zengwei123.github.io/"/>
  <updated>2018-08-06T13:08:46.648Z</updated>
  <id>https://zengwei123.github.io/</id>
  
  <author>
    <name>zengwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Api总结（持续跟新）</title>
    <link href="https://zengwei123.github.io/2017/08/06/Api/"/>
    <id>https://zengwei123.github.io/2017/08/06/Api/</id>
    <published>2017-08-06T04:46:49.000Z</published>
    <updated>2018-08-06T13:08:46.648Z</updated>
    
    <content type="html"><![CDATA[<p>这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取</p><hr><p>每日一文：<a href="https://interface.meiriyiwen.com/article/today?dev=1" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/today?dev=1</a><br>wc：字数(word count)<br>特定某天一文：<a href="https://interface.meiriyiwen.com/article/day?dev=1&amp;date=" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/day?dev=1&amp;date=</a> + 日期<br>随机一文：<a href="https://interface.meiriyiwen.com/article/random?dev=1" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/random?dev=1</a><br>解析：<br>&nbsp;&nbsp;&nbsp;&nbsp;date：日期<br>&nbsp;&nbsp;&nbsp;&nbsp;curr：今日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;prev：昨日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;next：明日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;author：作者<br>&nbsp;&nbsp;&nbsp;&nbsp;titile：标题<br>&nbsp;&nbsp;&nbsp;&nbsp;digest：首段<br>&nbsp;&nbsp;&nbsp;&nbsp;content：正文内容</p><hr><p>金山翻译：<a href="http://fy.iciba.com/ajax.php" target="_blank" rel="noopener">http://fy.iciba.com/ajax.php</a><br>url 示例：<a href="http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world" target="_blank" rel="noopener">http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world</a><br>拼接参数：<br>a：固定值 fy<br>f：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto<br>t：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto<br>w：查询内容</p><p>解析：<br>&nbsp;&nbsp;&nbsp;&nbsp;status：请求成功时则取 1<br>&nbsp;&nbsp;&nbsp;&nbsp;content：内容信息<br>&nbsp;&nbsp;&nbsp;&nbsp;from：原文内容类型<br>&nbsp;&nbsp;&nbsp;&nbsp;to：译文内容类型<br>&nbsp;&nbsp;&nbsp;&nbsp;vendor：来源平台<br>&nbsp;&nbsp;&nbsp;&nbsp;out：译文内容<br>&nbsp;&nbsp;&nbsp;&nbsp;err_no：请求成功时取 0</p><hr><p>必应图片：<a href="https://www.dujin.org/sys/bing/1920.php" target="_blank" rel="noopener">https://www.dujin.org/sys/bing/1920.php</a></p><hr><p>美女图片福利：<a href="http://gank.io/api/data/福利/10/1" target="_blank" rel="noopener">http://gank.io/api/data/福利/10/1</a><br>10和1可以是其他数字，自己去试区间</p><hr><p>一言： <a href="https://v1.hitokoto.cn/c=下面中的一个" target="_blank" rel="noopener">https://v1.hitokoto.cn/c=下面中的一个</a><br>a： 动画<br>b： 漫画<br>c： 游戏<br>d： 小说<br>e： 原创<br>f： 来自网络<br>g： 其他<br>其他不存在参数    任意类型随机取得</p><p>解析<br>id：本条一言的id。<br>hitokoto：一言正文。编码方式unicode。使用utf-8。<br>type：类型。请参考第三节参数的表格。<br>from：一言的出处。<br>creator：添加者。<br>created_at：添加时间。</p><hr><p>历史上的今天：<a href="http://www.ipip5.com/today/api.php?type=json" target="_blank" rel="noopener">http://www.ipip5.com/today/api.php?type=json</a></p><hr><p>美图接口api:<a href="https://pixabay.com/api/docs/" target="_blank" rel="noopener">https://pixabay.com/api/docs/</a><br>官网：<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a> </p><hr><p>新闻API：<a href="https://fenfa.shuwen.com" target="_blank" rel="noopener">https://fenfa.shuwen.com</a></p><hr><p>更多Api:<a href="https://github.com/jokermonn/-Api" target="_blank" rel="noopener">https://github.com/jokermonn/-Api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每日一文：&lt;a href=&quot;https://interface.meiriyiwen.com/article/today?dev=1&quot; t
      
    
    </summary>
    
      <category term="Api" scheme="https://zengwei123.github.io/categories/Api/"/>
    
    
  </entry>
  
  <entry>
    <title>Android四大组件之Service</title>
    <link href="https://zengwei123.github.io/2016/09/19/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/"/>
    <id>https://zengwei123.github.io/2016/09/19/Android四大组件之Service/</id>
    <published>2016-09-19T02:58:12.000Z</published>
    <updated>2018-08-07T03:38:39.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-Service作用："><a href="#1-Service作用：" class="headerlink" title="1.Service作用："></a>1.Service作用：</h4></blockquote><p>提供需要长期在后台长期运行的服务（如复杂计算、下载等），主要是因为它没有长的生命周期、没有用户界面、在后台运行。</p><blockquote><h4 id="2-Service分类："><a href="#2-Service分类：" class="headerlink" title="2.Service分类："></a>2.Service分类：</h4></blockquote><p><strong>本地</strong>：运行在主线程，主线程终止后服务也会终止。但是能够节约资源，并且通信方便，由于在同一进程不需要IPC和AIDL，主要使用在需要依附某个进程的服务，音乐播放等。<br><strong>远程</strong>：运行在独立进程，常驻在后台，不受其他Activity影响但是非常消耗资源，通讯需要比较复杂，主要使用在系统级别的服务。<br><strong>前台</strong>：通知栏可以显示出来，用户可以看到，主要使用在需要让用户只要并进行相关操作，如音乐播放。<br><strong>后台</strong>：主要是用户无法看到，主要使用在不需要让用户知道的一些操作，跟新数据，同步数据等</p><blockquote><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4></blockquote><p><strong>·</strong> 如果Service是第一次启动先会执行 <strong>onCreate(),onStartCommand()</strong><br><strong>·</strong> 当次启动Service调用，将只执行<strong>onStartCommand()</strong>，因为此时Service已经创建了，无需执行<strong>onCreate()</strong>回调。无论多少次的启动Service，只需要一次<strong>stopService()</strong>即可将此Service终止，执行<strong>onDestroy()</strong>函数。<br><strong>· onStartCommand(..)</strong>可以多次被调用，<strong>onDestroy()与onCreate()</strong>相匹配，当用户强制kill掉进程时，<strong>onDestroy()</strong>是不会执行的。<br><strong>· startService(Intent serviceIntent)</strong>，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。<br><strong>·</strong> 当Service需要运行在单独的进程中，<strong>AndroidManifest.xml</strong>声明时需要通过<strong>android:process</strong>指明此进程名称，当此Service需要对其他App开放时，<strong>android:exported</strong>属性值需要设置为true.</p><blockquote><h4 id="4-通讯"><a href="#4-通讯" class="headerlink" title="4.通讯"></a>4.通讯</h4></blockquote><ol><li>简单通信<br>直接通过Intent进行传值，我们在启动一个Service的时候通过Intent的对象向Service进行传值，这种方式传递值比较不方便，性能不是很高。<br>传值：<br><br><center><img src="/2016/09/19/Android四大组件之Service/1.png"></center><br><br>获取值：<br><br><center><img src="/2016/09/19/Android四大组件之Service/2.png"></center><br></li></ol><p>2．绑定服务传输数据<br>    在Service中编写Binder的内部类，自定义方法进行数据传输。<br>活动类：<br><br><center><img src="/2016/09/19/Android四大组件之Service/3.png"></center><br><br>服务类：<br><br><center><img src="/2016/09/19/Android四大组件之Service/4.png"></center><br></p><ol start="3"><li>通过使用Messenger方式（可以在不同进程间通讯）<br>服务端：<br><br><center><img src="/2016/09/19/Android四大组件之Service/5.png"></center><br><br>客户端<br><br><center><img src="/2016/09/19/Android四大组件之Service/6.png"></center><br></li></ol><blockquote><h4 id="5-服务单独运行在进程"><a href="#5-服务单独运行在进程" class="headerlink" title="5.服务单独运行在进程"></a>5.服务单独运行在进程</h4></blockquote><p>在XML文件中给Service添加process属性，有两种赋值方式，一种是[:xxxxx],一种是[com.pw.xxx.xxx]  第一种赋值是一种简写，完整的写法是[com.xxx.xxx:xxxx]这样的进程是应用的私有进程，其他应用不会跟它跑到同一个地方去。而第二种就是一种全局进程，其他的应用程序可以通过ShareUID跑进去。<br>多进程的使用地方，可以使用在一些需要保活的地方，音乐后台播放，在退出activity后还能继续播放、加载大图、推送服务，能够在程序退出后继续的向用户推送东西。将功能独立的分开来，减少程序崩溃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-Service作用：&quot;&gt;&lt;a href=&quot;#1-Service作用：&quot; class=&quot;headerlink&quot; title=&quot;1.Service作用：&quot;&gt;&lt;/a&gt;1.Service作用：&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;提供需
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android四大组件之Activity</title>
    <link href="https://zengwei123.github.io/2016/09/15/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/"/>
    <id>https://zengwei123.github.io/2016/09/15/Android四大组件之Activity/</id>
    <published>2016-09-15T01:09:23.000Z</published>
    <updated>2018-08-07T02:59:42.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-正常的周期"><a href="#1-正常的周期" class="headerlink" title="1.正常的周期"></a>1.正常的周期</h4></blockquote><p>OnCreate: 生命周期的第一个方法，可以做一些初始化的操作<br>onRestart: 表示activit正在重新启动，这一般是当activity从不可见变成可见时调用，一般是由用户行为导致<br>OnStart:这是说明activity正在被启动，即将开始。<br>OnResume:表示activity已经可以看见了，并且出现在前台，已经与用户进行交互了。在这里OnStart和OnResume都是出现已经可见了，但是OnStart还在后台而OnResume已经出现在了前台<br>OnPause:表示activity正在停止，这个时候OnStop马上回被调用，在这里已经进行一些数据存储，动画显示等不耗时的操作，因为OnPause要执行完才能执行其他activity的OnResume。<br>OnStop:表示activity即将停止，在这里可以做一些资源比较有重量的回收，但是也不能太过耗时。<br>OnDestroy:最后一个方法，表示activity活到头了，在这里可以做一些回收工作和资源释放</p><p>OnStart和OnResume、OnPause和OnStop这两对方法没有什么实质性的不同，OnResume是可见周期的最后一个方法已经结束了，OnStart是还正在启动，OnPauses要执行完之后才能执行新activity的方法，OnStop是结束周期中简的一个</p><blockquote><h4 id="2-异常的生命周期"><a href="#2-异常的生命周期" class="headerlink" title="2.异常的生命周期"></a>2.异常的生命周期</h4></blockquote><p>1、资源相关的系统配置发生改变导致<strong>activity</strong>被杀死重建<br>竖屏时变成横屏，由于设置了不同资源图片，<strong>activity</strong>会销毁重建。他会执行<br><strong>onPause</strong>→<strong>onSaveInstanceState</strong>→<strong>onStop</strong>→<strong>onDestroy</strong><br>然后<br><strong>onCreate</strong>→<strong>onStart</strong>→<strong>onResume</strong><br><strong>onSaceInstanceState</strong>是在异常结束<strong>activity</strong>时才会执行的方法，他会保存当前<strong>activity</strong>的状态同时会在新创建的<strong>activity</strong>调用<strong>onRestoreInstanceState</strong>方法并且将<strong>onSaceInstanceState</strong>方法保存的bundle传递给<strong>onCreate</strong>。我们可以在<strong>onSaceInstanceState</strong>中存储一些数据，在<strong>onRestoreInstanceState</strong>或者<strong>onCreate</strong>中读取，有一点<strong>onRestoreInstanceState</strong>如果执行那么<strong>Bundle</strong>是不会为空的，但是<strong>onCreate</strong>中就不知道了</p><p>2、资源不足导致优先级低的<strong>activity</strong>被杀死<br>优先级：前台<strong>activity</strong><br>        可见非前台<strong>activit</strong>（比如弹出一个对话框）<br>        后台<strong>activit</strong><br>杀死activity后，就会在有内存的时候通过<strong>onSaceInstanceState</strong> 保存<strong>onRestoreInstanceState</strong>恢复<br>可以通过设置<strong>android：configChanges=”orientation”</strong>  静止重建</p><blockquote><h4 id="3-Activity启动模式"><a href="#3-Activity启动模式" class="headerlink" title="3.Activity启动模式"></a>3.Activity启动模式</h4></blockquote><p>1、存在的意义：<br>多次启动同一个<strong>activity</strong>，多次创建同一个实例，这是很傻的行为<br>1.<strong>standard</strong>（默认）每次启动<strong>activity</strong>都会重新创建实例<br>2.<strong>singleTop</strong>（栈顶复用模式）  判断<strong>activity</strong>是否在任务栈顶，如果在直接引用，同时调用<strong>onNewIntent</strong>方法，如果不在就创建新的实例。<br>3.<strong>singleTask</strong>（栈内复用模式） 判断栈中是否有这个实例，如果有那么就使用这个实例，如果没有那么就创建一个，这个<strong>activity</strong>会调用<strong>onNewIntent</strong><br>4.<strong>singleInstance</strong>（单实例模式）这个是 <strong>singleTask</strong> 模式的加强版，它除了具有 <strong>singleTask</strong> 模式的所有特性外，它还有一点独特的特性，那就是此模式的 <strong>Activity</strong> 只能单独地位于一个任务栈，不与其他 <strong>Activity</strong> 共存于同一个任务栈。</p><p>2、什么是任务栈：<br>这是一个<strong>activity</strong>的参数<strong>TaskAffinity</strong>,这个参数标识了<strong>activity</strong>所需要的任务栈，默认情况下任务栈的名字为包名，我们可以给每个<strong>activity</strong>命一个名字，同名的是名字就是在一个任务栈，它主要是和<strong>singleTask</strong>或者<strong>allowTaskReparenting</strong>结合使用。<br>在<strong>TaskAffinity</strong>和<strong>allowTaskRepaernting</strong>一起使用且<strong>allowTaskRepaernting</strong>为<strong>true</strong>的时候如果当一个应用A的<strong>activity</strong>启动了一个应用B的<strong>activity</strong>，那么这个B应用的<strong>activity</strong>会直接从A的任务栈跑到B的任务栈。当返回桌面，点击应用B，他不会启动住<strong>activity</strong>，而会显示应用A启动的<strong>acitivity</strong></p><p>设置启动模式有两种方法：<br>1.通过<strong>launchMode</strong>指定<br>2.通过<strong>Intent.addFlage</strong>指定<br>第二种的优先级比第一种要高，第二种无法指定为第四种模式</p><p>3、Activity隐式调用<br>隐式调用能够设置一些过滤信息，如果不匹配将无法启动<strong>activity</strong>。<br>需要匹配：<strong>action、category、data</strong><br>Action：是一个字符串，这里指定匹配是字符串相同，在xml文件中如过指定了<strong>action</strong>，如果在<strong>intent</strong>中没有设置，那么是无法匹配成功的，想要匹配必须<strong>intent</strong>中的字符串与<strong>action</strong>的字符串相同。<br><strong>Category：Category</strong>中必须要有一个<strong>android.intent.Category.DEFAULT</strong>,而且intent可以不指定<strong>Category</strong>。<br>Date:规则跟action一样，如果定义了那么就要指定，Date主要是一个规则，用来放置url</p><p>我们还可以在配置文件的activity中设置android:screenOrientation属性来设置他的横竖屏显示portrait（竖屏），landscape （横屏）</p><p>全屏的 Activity<br>要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现：</p><pre><code>// 设置全屏模式getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏requestWindowFeature(Window.FEATURE_NO_TITLE);</code></pre><blockquote><h4 id="4-使用-Intent-通信"><a href="#4-使用-Intent-通信" class="headerlink" title="4.使用 Intent 通信"></a>4.使用 Intent 通信</h4></blockquote><p>在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。</p><p>在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。</p><p>如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去：</p><pre><code>Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity</code></pre><p>那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息：</p><pre><code>Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容bundle.getString(&quot;string_key&quot;);</code></pre><p>上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法：</p><pre><code>Intent intent =new Intent(EX06.this,OtherActivity.class);  intent.putExtra(&quot;boolean_key&quot;, true);  intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;);  startActivity(intent);</code></pre><p>接收：</p><pre><code>Intent intent=getIntent();  intent.getBooleanExtra(&quot;boolean_key&quot;,false);  intent.getStringExtra(&quot;string_key&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-正常的周期&quot;&gt;&lt;a href=&quot;#1-正常的周期&quot; class=&quot;headerlink&quot; title=&quot;1.正常的周期&quot;&gt;&lt;/a&gt;1.正常的周期&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;OnCreate: 生命周期的第一个方法，可以
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://zengwei123.github.io/2016/09/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zengwei123.github.io/2016/09/04/hexo常用命令/</id>
    <published>2016-09-04T08:25:04.000Z</published>
    <updated>2018-08-06T02:57:06.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog"><a href="#1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog" class="headerlink" title="1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog"></a>1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog</h4><blockquote><p>$ hexo init [folder]   </p></blockquote><p><br><br></p><h4 id="2-创建一篇文章，-layout-为博客文章布局，可以设置为下面三种布局之一-title-随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致"><a href="#2-创建一篇文章，-layout-为博客文章布局，可以设置为下面三种布局之一-title-随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致" class="headerlink" title="2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致"></a>2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致</h4><ul><li><h5 id="·-post-nbsp-nbsp-我一般都用post，默认就是这个"><a href="#·-post-nbsp-nbsp-我一般都用post，默认就是这个" class="headerlink" title="· post&nbsp;&nbsp;我一般都用post，默认就是这个"></a>· post&nbsp;&nbsp;我一般都用post，默认就是这个</h5></li><li><h5 id="·-page"><a href="#·-page" class="headerlink" title="· page"></a>· page</h5></li><li><h5 id="·-draft"><a href="#·-draft" class="headerlink" title="· draft"></a>· draft</h5></li></ul><blockquote><p>$ hexo new [layout] <title></title></p></blockquote><hr><p>文章建立之后，在你的网站文件夹中<span style="color:#ff0000"> <strong>\source\_posts</strong> </span> 路径下面可以找到创建的文章文件，是 <strong>markdown</strong> 格式的，文件后缀名为 <strong>.md</strong>, <strong>Front-matter</strong> 是文件最上方以 — 分隔的区域，用于指定个别文件的变量,以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><ul><li><strong>·</strong> layout 布局</li><li><strong>·</strong> title 标题</li><li><strong>·</strong> date 建立日期</li><li><strong>·</strong> updated 更新日期</li><li><strong>·</strong> comments 开启文章的评论功能</li><li><strong>·</strong> tags 标签</li><li><strong>·</strong> categories 分类</li><li><strong>·</strong> permalink 覆盖文章网址<br><br><br><h4 id="3-将更改上传到github-每次更新完博客输入这条命令，就能将文章跟新到博客了"><a href="#3-将更改上传到github-每次更新完博客输入这条命令，就能将文章跟新到博客了" class="headerlink" title="3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了"></a>3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了</h4><blockquote><p>$ hexo g -d</p></blockquote></li></ul><p><br><br></p><h4 id="4-启动本地服务-可以在写完文章后查看效果"><a href="#4-启动本地服务-可以在写完文章后查看效果" class="headerlink" title="4.启动本地服务,可以在写完文章后查看效果"></a>4.启动本地服务,可以在写完文章后查看效果</h4><blockquote><p>$ hexo s</p></blockquote><p><br><br></p><h4 id="5-有时候博客写完，上传giehub无效果，那么试试清除缓存"><a href="#5-有时候博客写完，上传giehub无效果，那么试试清除缓存" class="headerlink" title="5.有时候博客写完，上传giehub无效果，那么试试清除缓存"></a>5.有时候博客写完，上传giehub无效果，那么试试清除缓存</h4><blockquote><p>$ hexo clean</p></blockquote><p><br><br><br>基本的hexo编写博客的使用就到这里了，使用上面几条命令就能够创建编写上传你的文章到博客去。其他的一些操作可以去hexo官网查看官方文档<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">HEXO官方文档</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog&quot;&gt;&lt;a href=&quot;#1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地
      
    
    </summary>
    
      <category term="Hexo" scheme="https://zengwei123.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://zengwei123.github.io/2016/09/02/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zengwei123.github.io/2016/09/02/hexo搭建博客/</id>
    <published>2016-09-02T15:15:04.000Z</published>
    <updated>2018-08-06T07:16:01.561Z</updated>
    
    <content type="html"><![CDATA[<p>花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！</p><p>   Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致配置不一样，我是windows所有</p><blockquote><h4 id="1-安装git与node-js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的"><a href="#1-安装git与node-js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的" class="headerlink" title="1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的"></a>1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的</h4></blockquote><p>安装git、node.js，首先官网去下载安装包，如果是mac一行命令的事情，然后一直下一步下一步下一步就ok,没有什么其他的出问题百度吧，这里就不多说了，下面贴上两个东西的下载地址<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下找地址</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js下找地址</a></p><blockquote><h4 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h4></blockquote><p>安装好Git后，桌面右击会增加两个东西 <strong><em>Git GUI here</em></strong> 、<strong><em>Git Bash here</em></strong> 这两个东西，点击Bash,就进入了Git的终端命令的界面了，你就可以快乐的敲命令了，输入 </p><p><span style="color:red"><strong>npm install -g hexo-cli</strong><br></span></p><p>刷刷刷，然后Hexo就安装好了，你就可以搭建你的博客了</p><blockquote><h4 id="3-建站"><a href="#3-建站" class="headerlink" title="3.建站"></a>3.建站</h4></blockquote><p>首先先创建你的网站，在git命令终端用下面这个命令</p><p></p><p><span style="color:red"><strong>hexo init folder</strong></span></p><p>folder可以自己随意命名，也可以随意指定路径，然后等待一会就把网站给你创建好了，在创建的命令信息中你可以看到自己创建的网站路径，记住这个路径，然后你可以输入</p><p><span style="color:red"><strong>hexo s</strong></span></p><p>这个命令启动服务来本地运行网站，浏览器输入：127.0.0.1:4000 就能够看到Hexo默认的主题我网站，这样我们就已经建好站了</p><blockquote><h4 id="4-配置到Github"><a href="#4-配置到Github" class="headerlink" title="4.配置到Github"></a>4.配置到Github</h4></blockquote><p>首先在github上面创建一个仓库名字叫做：用户名.github.io,注意用户名一定要跟自己的github账户相同<center><img src="/2016/09/02/hexo搭建博客/s.jpg"></center><br>创建仓库<br><center><img src="/2016/09/02/hexo搭建博客/2.jpg"></center><br><br>创建好仓库之后拿到他的ssh地址或者Https地址<br><center><img src="/2016/09/02/hexo搭建博客/3.jpg"></center><br><br>这样我们就吧hexo对应的github仓库建立好了，然后来到博客根路径下，打开_config.yml这个文件夹<br>找到下面这一段，将repository的内容替换成你自己刚刚拿到的ssh或HTTPs地址<br><center><img src="/2016/09/02/hexo搭建博客/4.png"></center><br>然后在再到下面这段，将里面的url换成你自己的：用户名.github.io(注意：这个url就是你以后博客的地址)<br><br><center><img src="/2016/09/02/hexo搭建博客/6.png"></center><br><br>到这里我们基本上就跟github关联起来了，但是为了以后更加方便，我们配置一下SSH</p><blockquote><h4 id="5-配置SSH"><a href="#5-配置SSH" class="headerlink" title="5.配置SSH"></a>5.配置SSH</h4></blockquote><p>首先，终端中输入cd ~/.ssh 查看有没有SSH如果有就删除吧，然后输入ssh-keygen -t rsa -C “你的邮箱”<br>，后面会要你输入密码，这个不用管，一直回车，最后如果出现下面这个图的样子，就是成功了<br><center><img src="/2016/09/02/hexo搭建博客/7.png"></center><br><br>然后到类似于：C:\Users\13085.ssh这种的目录下找到一个叫id_rsa.pub的文件，打开将里面的东西全部复制，进入GitHub<br><center><img src="/2016/09/02/hexo搭建博客/8.png"></center><br><br><center><img src="/2016/09/02/hexo搭建博客/9.png"></center><br><br>到这里，SSH就全部配置完了</p><blockquote><h4 id="6-上传网站"><a href="#6-上传网站" class="headerlink" title="6.上传网站"></a>6.上传网站</h4></blockquote><p>输入命令hexo g，此时若出现如下报错：<br>ERROR Local hexo not found in ~/blog<br>ERROR Try runing: ‘npm install hexo –save’<br>则执行命令：<br><span style="color:red"><strong>npm install hexo –save</strong></span><br>若无报错，自行忽略此步骤。</p><p>然后输入hexo d,若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：<br><span style="color:red"><strong>npm install hexo-deployer-git –save</strong></span></p><blockquote><h4 id="7-查看网站"><a href="#7-查看网站" class="headerlink" title="7.查看网站"></a>7.查看网站</h4></blockquote><p> 打开浏览器输入：https://你的用户名.github.io，就能够看到你的网站了，跟前面本地看到的效果是一样的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！&lt;/p&gt;
&lt;p&gt;   Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致
      
    
    </summary>
    
      <category term="Hexo" scheme="https://zengwei123.github.io/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
