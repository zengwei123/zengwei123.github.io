<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zengwei</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zengwei123.github.io/"/>
  <updated>2018-08-06T13:08:46.648Z</updated>
  <id>https://zengwei123.github.io/</id>
  
  <author>
    <name>zengwei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Api总结（持续跟新）</title>
    <link href="https://zengwei123.github.io/2017/08/06/Api/"/>
    <id>https://zengwei123.github.io/2017/08/06/Api/</id>
    <published>2017-08-06T04:46:49.000Z</published>
    <updated>2018-08-06T13:08:46.648Z</updated>
    
    <content type="html"><![CDATA[<p>这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取</p><hr><p>每日一文：<a href="https://interface.meiriyiwen.com/article/today?dev=1" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/today?dev=1</a><br>wc：字数(word count)<br>特定某天一文：<a href="https://interface.meiriyiwen.com/article/day?dev=1&amp;date=" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/day?dev=1&amp;date=</a> + 日期<br>随机一文：<a href="https://interface.meiriyiwen.com/article/random?dev=1" target="_blank" rel="noopener">https://interface.meiriyiwen.com/article/random?dev=1</a><br>解析：<br>&nbsp;&nbsp;&nbsp;&nbsp;date：日期<br>&nbsp;&nbsp;&nbsp;&nbsp;curr：今日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;prev：昨日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;next：明日日期，yyyyMMdd 格式<br>&nbsp;&nbsp;&nbsp;&nbsp;author：作者<br>&nbsp;&nbsp;&nbsp;&nbsp;titile：标题<br>&nbsp;&nbsp;&nbsp;&nbsp;digest：首段<br>&nbsp;&nbsp;&nbsp;&nbsp;content：正文内容</p><hr><p>金山翻译：<a href="http://fy.iciba.com/ajax.php" target="_blank" rel="noopener">http://fy.iciba.com/ajax.php</a><br>url 示例：<a href="http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world" target="_blank" rel="noopener">http://fy.iciba.com/ajax.php?a=fy&amp;f=auto&amp;t=auto&amp;w=hello%20world</a><br>拼接参数：<br>a：固定值 fy<br>f：原文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto<br>t：译文内容类型，日语取 ja，中文取 zh，英语取 en，韩语取 ko，德语取 de，西班牙语取 es，法语取 fr，自动则取 auto<br>w：查询内容</p><p>解析：<br>&nbsp;&nbsp;&nbsp;&nbsp;status：请求成功时则取 1<br>&nbsp;&nbsp;&nbsp;&nbsp;content：内容信息<br>&nbsp;&nbsp;&nbsp;&nbsp;from：原文内容类型<br>&nbsp;&nbsp;&nbsp;&nbsp;to：译文内容类型<br>&nbsp;&nbsp;&nbsp;&nbsp;vendor：来源平台<br>&nbsp;&nbsp;&nbsp;&nbsp;out：译文内容<br>&nbsp;&nbsp;&nbsp;&nbsp;err_no：请求成功时取 0</p><hr><p>必应图片：<a href="https://www.dujin.org/sys/bing/1920.php" target="_blank" rel="noopener">https://www.dujin.org/sys/bing/1920.php</a></p><hr><p>美女图片福利：<a href="http://gank.io/api/data/福利/10/1" target="_blank" rel="noopener">http://gank.io/api/data/福利/10/1</a><br>10和1可以是其他数字，自己去试区间</p><hr><p>一言： <a href="https://v1.hitokoto.cn/c=下面中的一个" target="_blank" rel="noopener">https://v1.hitokoto.cn/c=下面中的一个</a><br>a： 动画<br>b： 漫画<br>c： 游戏<br>d： 小说<br>e： 原创<br>f： 来自网络<br>g： 其他<br>其他不存在参数    任意类型随机取得</p><p>解析<br>id：本条一言的id。<br>hitokoto：一言正文。编码方式unicode。使用utf-8。<br>type：类型。请参考第三节参数的表格。<br>from：一言的出处。<br>creator：添加者。<br>created_at：添加时间。</p><hr><p>历史上的今天：<a href="http://www.ipip5.com/today/api.php?type=json" target="_blank" rel="noopener">http://www.ipip5.com/today/api.php?type=json</a></p><hr><p>美图接口api:<a href="https://pixabay.com/api/docs/" target="_blank" rel="noopener">https://pixabay.com/api/docs/</a><br>官网：<a href="https://pixabay.com/zh/" target="_blank" rel="noopener">https://pixabay.com/zh/</a> </p><hr><p>新闻API：<a href="https://fenfa.shuwen.com" target="_blank" rel="noopener">https://fenfa.shuwen.com</a></p><hr><p>更多Api:<a href="https://github.com/jokermonn/-Api" target="_blank" rel="noopener">https://github.com/jokermonn/-Api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里我将一些网络上找到的Api接口总结起来，方便以后使用，这里声明：所有Api，本人皆从网络获取，并非本人抓取&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每日一文：&lt;a href=&quot;https://interface.meiriyiwen.com/article/today?dev=1&quot; t
      
    
    </summary>
    
      <category term="Api" scheme="https://zengwei123.github.io/categories/Api/"/>
    
    
  </entry>
  
  <entry>
    <title>Android动画2</title>
    <link href="https://zengwei123.github.io/2016/11/27/Android%E5%8A%A8%E7%94%BB2/"/>
    <id>https://zengwei123.github.io/2016/11/27/Android动画2/</id>
    <published>2016-11-27T01:16:27.000Z</published>
    <updated>2018-08-22T07:43:05.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="安卓在5-0以后有一些新的动画："><a href="#安卓在5-0以后有一些新的动画：" class="headerlink" title="安卓在5.0以后有一些新的动画："></a>安卓在5.0以后有一些新的动画：</h4><ul><li><strong>·</strong> Touch feedback（触摸反馈）</li><li><strong>·</strong> Reveal effect（揭露效果）</li><li><strong>·</strong> Activity transitions（Activity转换效果）</li><li><strong>·</strong> Curved motion（曲线运动）</li><li><strong>·</strong> View state changes（视图状态改变）</li></ul></blockquote><p>下面一个一个的来说</p><blockquote><h3 id="1-触摸反馈"><a href="#1-触摸反馈" class="headerlink" title="1.触摸反馈"></a>1.触摸反馈</h3></blockquote><p>顾名思义，触摸的时候给你一个反馈，最典型的就是<strong>Button</strong>默认的水波纹了，当使用了Material主题之后，波纹动画会自动安装到所有的控件上面。当然，我们也可以设置了，上面的第一种是设置波纹有边界，第二种是设置波纹超出边界。第二种需要5.0以上才行。<br>这里注意：除了Button外，如果像TextView这些控件，需要给予点击事件才能够有效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:background=<span class="string">"?android:attr/selectableItemBackground"</span></span><br><span class="line">android:background=<span class="string">"?android:attr/selectableItemBackgroundBorderless"</span></span><br></pre></td></tr></table></figure></p><p><br><center><img src="/2016/11/27/Android动画2/GIF1.gif"><img src="/2016/11/27/Android动画2/GIF2.gif"></center><br><br>如果你觉得默认的颜色丑，那么你还可以自己区设置颜色，在drawable创建一个ripple的xml文件，android：background=”在这里引用就行”;<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ripple xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span> android:color=<span class="string">"#ffff00"</span> android:radius=<span class="string">"200dp"</span>&gt;</span><br><span class="line"> &lt;item android:drawable="@android:color/background_light"&gt;&lt;/item&gt;   &lt;!--把这个删除掉就是第二种无边框状态--&gt;</span><br><span class="line">&lt;/ripple&gt;</span><br></pre></td></tr></table></figure></p><blockquote><h3 id="2-视图状态改变"><a href="#2-视图状态改变" class="headerlink" title="2.视图状态改变"></a>2.视图状态改变</h3></blockquote><p>除了这种水波纹之外，我们还可以定义自己的动画，使用android:stateListAnimator，这个东西，我们先看看效果：<br><br><center><img src="/2016/11/27/Android动画2/GIF3.gif"></center><br><br>像这个翻转动画就是我们自己定义的，使用这个也很简单，在animator下创建一个XML文件，看下面的代码你可会发现是一个objectAnimator，这个跟属性动画的xml编写是一样的，android:state_pressed=”true” 按下false为抬起。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:duration</span>=<span class="string">"500"</span> <span class="attr">android:propertyName</span>=<span class="string">"rotationX"</span> <span class="attr">android:valueTo</span>=<span class="string">"360"</span> <span class="attr">android:valueType</span>=<span class="string">"floatType"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">objectAnimator</span> <span class="attr">android:duration</span>=<span class="string">"500"</span> <span class="attr">android:propertyName</span>=<span class="string">"rotationX"</span> <span class="attr">android:valueTo</span>=<span class="string">"0"</span> <span class="attr">android:valueType</span>=<span class="string">"floatType"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们怎么使用这个动画呢？两种方法第一代码实现，第种二配置android:stateListAnimator=”@nimator/XXX.xml“<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StateListAnimator stateListAnimator= AnimatorInflater.loadStateListAnimator(getApplicationContext(),R.animator.asd);</span><br><span class="line">textView.setStateListAnimator(stateListAnimator);</span><br></pre></td></tr></table></figure></p><blockquote><h3 id="3-揭露效果"><a href="#3-揭露效果" class="headerlink" title="3.揭露效果"></a>3.揭露效果</h3></blockquote><p><br><center><img src="/2016/11/27/Android动画2/GIF4.gif"></center><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Animator animator = ViewAnimationUtils.createCircularReveal(textView,</span><br><span class="line">                        textView.getWidth()/<span class="number">2</span>,</span><br><span class="line">                        textView.getHeight()/<span class="number">2</span>,</span><br><span class="line">                        textView.getWidth(),<span class="number">0</span>);</span><br><span class="line">                animator.setInterpolator(<span class="keyword">new</span> AccelerateDecelerateInterpolator());</span><br><span class="line">                animator.setDuration(<span class="number">5000</span>);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure></p><p>方法的第一个参数是你要操作的view,第二个是原中心的X方向中点，第三个是圆Y方向的中点，第四个是原开始的半径，第五个是结束时候的半径。</p><blockquote><h3 id="4-曲线运动"><a href="#4-曲线运动" class="headerlink" title="4.曲线运动"></a>4.曲线运动</h3></blockquote><p><br><center><img src="/2016/11/27/Android动画2/GIF5.gif"></center><br><br>曲线运动很容易，就是画一个贝塞尔曲线出来，然后沿着轨迹运动，他的使用方法跟属性动画一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">   path.moveTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   path.quadTo(<span class="number">200</span>, <span class="number">200</span>,<span class="number">400</span>,<span class="number">0</span>);</span><br><span class="line">   ObjectAnimator mAnimator=ObjectAnimator.ofFloat(textView, View.X, View.Y, path);</span><br><span class="line">   mAnimator.setDuration(<span class="number">2000</span>);</span><br><span class="line">   mAnimator.setEvaluator(<span class="keyword">new</span> FloatEvaluator());</span><br><span class="line">   mAnimator.setRepeatCount(-<span class="number">1</span>);</span><br><span class="line">   mAnimator.setRepeatMode(ObjectAnimator.REVERSE);</span><br><span class="line">   mAnimator.start();</span><br></pre></td></tr></table></figure></p><blockquote><h3 id="5-Activity转换效果"><a href="#5-Activity转换效果" class="headerlink" title="5.Activity转换效果"></a>5.Activity转换效果</h3></blockquote><p>在Android L之前，我们可以在startActivity之后调用overridePendingTransition来指定Activity的转场动画。现在Android L给我们带来了更绚丽的转场动画。<br>新的转场动画分为两大类，一种是普通的过渡动画，另一种是共享元素的过渡动画。 要想使用新的转场动画，可以继承Material Design主题后在style风格中指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"DefaultTheme"</span> <span class="attr">parent</span>=<span class="string">"android:Theme.Material"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 允许使用transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowContentTransitions"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 指定进入、退出、返回、重新进入时的transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowEnterTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowExitTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReturnTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowReenterTransition"</span>&gt;</span>@transition/explode<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 指定进入、退出、返回、重新进入时的共享transitions --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementEnterTransition"</span>&gt;</span>@transition/change<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementExitTransition"</span>&gt;</span>@transition/change<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementReturnTransition"</span>&gt;</span>@transition/change<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowSharedElementReenterTransition"</span>&gt;</span>@transition/change<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>也可以在activity的oncreate方法中进行代码设置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许使用transitions</span></span><br><span class="line">getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</span><br><span class="line"><span class="comment">// 指定进入、退出、返回、重新进入时的transitions</span></span><br><span class="line">getWindow().setEnterTransition(<span class="keyword">new</span> Explode());</span><br><span class="line">getWindow().setExitTransition(<span class="keyword">new</span> Explode());</span><br><span class="line">getWindow().setEnterTransition(<span class="keyword">new</span> Explode());</span><br><span class="line">getWindow().setExitTransition(<span class="keyword">new</span> Explode());</span><br><span class="line"><span class="comment">// 指定进入、退出、返回、重新进入时的共享transitions</span></span><br><span class="line">getWindow().setSharedElementEnterTransition(<span class="keyword">new</span> ChangeTransform());</span><br><span class="line">getWindow().setSharedElementExitTransition(<span class="keyword">new</span> ChangeTransform());</span><br><span class="line">getWindow().setSharedElementReturnTransition(<span class="keyword">new</span> ChangeTransform());</span><br><span class="line">getWindow().setSharedElementReenterTransition(<span class="keyword">new</span> ChangeTransform());</span><br></pre></td></tr></table></figure></p><p>普通转场动画<br>所有继承自visibility类都可以作为进入、退出的过度动画。如果我们想自定义进入和退出时的动画效果，只需要继承Visibility，重载onAppear和onDisappear方法来定义进入喝退出的动画。系统提供了三种默认方式：</p><ul><li>explode 从屏幕中心移入或移出视图</li><li>slide 从屏幕边缘移入或移出视图</li><li>fade 改变视图的透明度<br>想在xml中指定自定义的进入、退出的过度动画需要先对动画进行定义：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">class</span>=<span class="string">"my.app.transition.CustomTransition"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：其中CustomTransition是你自定义的动画，它必须继承自Visibility。<br>想以普通转场动画的方式启动一个Activity，必须在startActivity函数中传递一个ActivityOptions的Bundle对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity);  </span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure></p><p>如果想让返回也具备转场效果，那么在返回的Activity中不要再调用finish函数，而是应该使用finishAfterTransition来结束一个Activity，该函数会等待动画执行完毕才结束该Activity。</p><p>共享转场动画<br>当两个Activity具备某些相遇的元素时，共享转场动画将是一个非常好的选择。使用转场动画需要将相同的元素通过android:transitionName或者view.setTransitionName设置为相同的名称，这样系统才能区分出相同的元素。</p><p>共享转场动画支持以下共享元素：</p><p>changeBounds 对目标视图的大小进行动画<br>changeClipBounds 对目标视图的剪裁大小进行动画<br>changeTransform 对目标视图进行缩放、旋转、位移动画<br>changeImageTransform 对目标图片进行缩放<br>通过下面的函数启动一个共享元素动画：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity, view, <span class="string">"name"</span>);  </span><br><span class="line">startActivity(intent, options.toBundle());</span><br></pre></td></tr></table></figure></p><p>如果有多个共享元素，则可以通过Pair进行包装处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(activity,Pair.create(view1, <span class="string">"name1"</span>),Pair.create(view2, <span class="string">"name2"</span>));      </span><br><span class="line">startActivity(intent,.toBundle());</span><br></pre></td></tr></table></figure></p><p>返回时如果需要具备转场动画，那么也需要用finish函数替代finishAfterTransition来结束一个Activity。</p><p>共享转场动画通常可以根据指定的元素判断出合适的转场动画效果，不需要我们做额外的处理，也可以通过之前学习的方法进行指定共享元素转场动画效果。</p><p>组合转场动画<br>我们可以把多个转场动画进行组合，作出更具个性的转场效果，在资源文件中通过以下方式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transitionSet</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">explode</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">class</span>=<span class="string">"my.app.transition.CustomTransition"</span>/&gt;</span></span><br><span class="line">    &lt;&lt;changeImageTransform/&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">transitionSet</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代码中我们可以通过TransitionSet类组合多个转场动画：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TransitionSet transitionSet = <span class="keyword">new</span> TransitionSet();</span><br><span class="line">transitionSet.addTransition(<span class="keyword">new</span> Fade());</span><br><span class="line">transitionSet.addTransition(<span class="keyword">new</span> ChangeBounds());</span><br></pre></td></tr></table></figure></p><p>组合可以同时针对普通转场动画和共享元素转场动画。</p><p>转场动画也可以像普通动画一样设置持续时间，延期执行时间，速率插入器，以及动画的监听等。</p><p>转场动画通常是对整个布局起作用，如果我们想对某个特定的view实施转场动画，可以把该view设置为转场动画的target，这样转场动画将只对特定的view起作用。共享元素的动画的target需要指定为transitionName</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;安卓在5-0以后有一些新的动画：&quot;&gt;&lt;a href=&quot;#安卓在5-0以后有一些新的动画：&quot; class=&quot;headerlink&quot; title=&quot;安卓在5.0以后有一些新的动画：&quot;&gt;&lt;/a&gt;安卓在5.0以后有一些新的动画：&lt;/h4&gt;&lt;ul&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android动画</title>
    <link href="https://zengwei123.github.io/2016/11/25/Android%E5%8A%A8%E7%94%BB/"/>
    <id>https://zengwei123.github.io/2016/11/25/Android动画/</id>
    <published>2016-11-25T09:20:52.000Z</published>
    <updated>2018-08-20T03:10:54.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。"><a href="#安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。" class="headerlink" title="安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。"></a>安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。</h4></blockquote><h3 id="1-View动画"><a href="#1-View动画" class="headerlink" title="1.View动画"></a>1.View动画</h3><hr><p><br><center><img src="/2016/11/25/Android动画/GIF9.gif"></center><br><br>view动画的对象是View,他有四种动画效果，这四种效果都对应着四个类</p><ul><li><strong>平移-&lt;translate>-TranslateAnimation</strong></li><li><strong>缩放-&lt;scale>-ScaleAnimation</strong></li><li><strong>旋转-&lt;rotate>-RotateAnimation</strong></li><li><strong>透明-&lt;alpha>-AlphaAnimation</strong></li></ul><p>看下面的代码，就知道怎么使用了，set是一个动画集合，他会执行你所有定义了的动画，也就是说下面的这些动画会同时执行，这个文件创建在 /res/anim/xxx.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fillAfter</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        android:fillAfter="true"  //这属性说明的的动画结束后是否停留在结束位置，true为停留，false为不停留</span></span><br><span class="line"><span class="comment">        android:duration="500"    //这个是这组动画执行的事件</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--平移动画--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        android:fromXDelta="500"  //X的起始位置</span></span><br><span class="line"><span class="comment">        android:fromYDelta="0"    //Y的其实位置</span></span><br><span class="line"><span class="comment">        android:toXDelta="0"     //X的结束位置</span></span><br><span class="line"><span class="comment">        android:toYDelta="0"     //Y的结束位置</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">translate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXDelta</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--缩放动画--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        android:fromXScale="1.0" //X的缩放起始值</span></span><br><span class="line"><span class="comment">        android:fromYScale="1.0"   //Y的缩放其实值</span></span><br><span class="line"><span class="comment">        android:toXScale="1.5"     //X的缩放结束值</span></span><br><span class="line"><span class="comment">        android:toYScale="1.5"     //Y的缩放结束值</span></span><br><span class="line"><span class="comment">        android:pivotX="100"     //缩放点的X轴</span></span><br><span class="line"><span class="comment">        android:pivotY="50"      //缩放点的Y轴</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scale</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromXScale</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromYScale</span>=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toXScale</span>=<span class="string">"1.5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toYScale</span>=<span class="string">"1.5"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">"50"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--旋转动画--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        android:fromDegrees="50" //旋转开始的角度</span></span><br><span class="line"><span class="comment">        android:toDegrees="180"     //旋转结束的角度</span></span><br><span class="line"><span class="comment">        android:pivotX="0"        //旋转的转轴X坐标</span></span><br><span class="line"><span class="comment">        android:pivotY="0"        //旋转的转轴Y坐标</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromDegrees</span>=<span class="string">"50"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toDegrees</span>=<span class="string">"180"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotX</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pivotY</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--透明动画--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        android:fromAlpha="1" //起始透明</span></span><br><span class="line"><span class="comment">        android:toAlpha="0.2"     //结束透明度</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">"0.2"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>那么如何使用这个动画呢？看下面</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取你的动画</span><br><span class="line">Animation animation= AnimationUtils.loadAnimation(getApplicationContext(),R.anim.my);</span><br><span class="line">//使用你的动画</span><br><span class="line">button.startAnimation(animation);</span><br></pre></td></tr></table></figure><p>不仅仅只能用xml的形式来使用动画，还可以用代码的方式，嗯，代码方式难得敲了，百度找吧</p><blockquote><h4 id="1-1-layoutAnimation"><a href="#1-1-layoutAnimation" class="headerlink" title="1.1 layoutAnimation"></a>1.1 layoutAnimation</h4><p>我们有时候会看到一些列表有初始的进入动画，类似与下面这种，他使用的是LayoutAnimation,他的作用是给ViewGroup加上一个动画，这样它的子控件就都有这种效果了，使用这个东西首先你要定义一个layoutAnimation，这个文件创建在 /res/anim/xxx.xml<br><br><center><img src="/2016/11/25/Android动画/GIF11.gif"></center><br></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layoutAnimation</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:delay</span>=<span class="string">"10%"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:animationOrder</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:animation</span>=<span class="string">"@anim/my"</span>    //这个属性是你的动画</span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">layoutAnimation</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在ViewGroup的 android:layoutAnimation=”@anim/layout”  加上你刚刚定义的layoutAnimation，这样子你的ViewGroup就都有出场动画了，但是有一点，在列表中的时候只有看的见的控件才有动画，看不见的是没有的，加载完成后你将它滑动显示，他是没有动画的，所以说你的动画要设计的要与这些没有动画的控件看起来协调。<br><br></p><blockquote><h4 id="1-2-Activity的切换效果"><a href="#1-2-Activity的切换效果" class="headerlink" title="1.2 Activity的切换效果"></a>1.2 Activity的切换效果</h4><p>主要是通过overridePendintTransition(int enterAnim,int exitAnim)这个方法,这个方法使用在<strong>startActivity(intent)</strong>，或者<strong>finish</strong>之后。<br>enterAnim    Activity打开时调用的动画资源<br>exitAnim     Activity被暂停调用的动画资源<br><br></p></blockquote><h3 id="2-帧动画"><a href="#2-帧动画" class="headerlink" title="2.帧动画"></a>2.帧动画</h3><hr><p><br><center><img src="/2016/11/25/Android动画/GIF10.gif"></center><br><br>帧动画怎么说呢，就是一组图片，然后循环播放，它使用发放比较简单，但是比较容易引起内存泄露，所以使用帧动画应该避免过多的使用尺寸较大的图片<br><br><center><img src="/2016/11/25/Android动画/1.png"></center><br><br>xml文件的代码,duration代表的是每张图片的时间<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> <span class="attr">android:oneshot</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_01"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_02"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_03"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_04"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_05"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_06"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_07"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_08"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_09"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_10"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_11"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_loading_white_12"</span> <span class="attr">android:duration</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后使用它,这里是用AnimationDrawable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setBackgroundResource(R.drawable.zhen);</span><br><span class="line">AnimationDrawable animationDrawable= (AnimationDrawable) button.getBackground();</span><br><span class="line">animationDrawable.start();</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="3-属性动画"><a href="#3-属性动画" class="headerlink" title="3.属性动画"></a>3.属性动画</h3><hr><blockquote><h4 id="3-1-ObjectAnimator"><a href="#3-1-ObjectAnimator" class="headerlink" title="3.1 ObjectAnimator"></a>3.1 ObjectAnimator</h4></blockquote><p>对于View动画我们只能够对其进行平移、旋转、透明，缩放进行操作，并且View动画进行改变之后，他是没有改变View的属性的，比如，你使用平移将控件平移100,但是你去出发他的点击事件，你会发现触发不了，点击原来的位置才能够出发，这就是View动画的局限性了，所以出来了属性动画，属性动画额能够对对象的属性进行操作，所以属性动画基本上是无所能的。</p><blockquote><p>ObjiecAnimator的使用有一点很重要，就是在设置他的属性的时候必须要有set方法。因为有Set方法我们才能够对它进行属性的改变。</p></blockquote><h5 id="使用方法，"><a href="#使用方法，" class="headerlink" title="使用方法，"></a>使用方法，</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(button,<span class="string">"translationX"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);</span><br><span class="line">objectAnimator.setDuration(<span class="number">2000</span>);</span><br><span class="line">objectAnimator.start();</span><br></pre></td></tr></table></figure><p>看到上面的代码是不是很简单呢，是的属性动画的使用方法非常简单，但是还是有一些其他的方法，来让我们更好的使用属性动画<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objectAnimator.setEvaluator(<span class="keyword">new</span> ArgbEvaluator());    <span class="comment">//设置一个估值器，常用的有ArgbEvaluator\IntEvaluator\FloatEvaluator</span></span><br><span class="line">objectAnimator.setRepeatCount(-<span class="number">1</span>);           <span class="comment">//动画的重复次数 -1代表无限重复</span></span><br><span class="line">objectAnimator.setRepeatMode(ObjectAnimator.REVERSE);    <span class="comment">//重复模式 REVERSE逆向重复  REPEAT 连续重复</span></span><br><span class="line">objectAnimator.setDuration(<span class="number">2000</span>);             <span class="comment">//动画持续时间</span></span><br><span class="line">objectAnimator.setStartOffset(<span class="number">2000</span>);      <span class="comment">//延迟时间</span></span><br></pre></td></tr></table></figure></p><p>下面列举一些常用的属性动画<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofInt(button,<span class="string">"backgroundColor"</span>, Color.RED,Color.YELLOW,Color.BLUE);  <span class="comment">//背景颜色的改变</span></span><br><span class="line">ObjectAnimator.ofInt(button,<span class="string">"textColor"</span>, Color.RED,Color.YELLOW,Color.BLUE);  <span class="comment">//字体颜色的改变</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"textSize"</span>, <span class="number">15f</span>,<span class="number">30f</span>);    <span class="comment">//字体大小</span></span><br><span class="line"></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"translationX"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);   <span class="comment">//X（左右）轴平移</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"translationY"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);<span class="comment">//Y（上下）轴平移</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"translationZ"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);<span class="comment">//Z（高度）轴平移</span></span><br><span class="line"><span class="comment">//这里是旋转这里注意一下他可以设置旋转的轴心，原本旋转是控件的中心，你可以通过下面两个方法来设置轴心</span></span><br><span class="line">button.setPivotX(<span class="number">0</span>);</span><br><span class="line">button.setPivotY(<span class="number">0</span>);</span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"rotationX"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);    <span class="comment">//沿X旋转</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"rotationY"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);<span class="comment">//沿Y旋转</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"rotation"</span>, <span class="number">0f</span>,<span class="number">1000f</span>);    <span class="comment">//平面旋转</span></span><br><span class="line"><span class="comment">//缩放动画</span></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"scaleY"</span>, <span class="number">1f</span>,<span class="number">2F</span>);      </span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"scaleX"</span>, <span class="number">1f</span>,<span class="number">2F</span>);</span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"textScaleX"</span>, <span class="number">1f</span>,<span class="number">2F</span>);    <span class="comment">//这个是字体的缩放</span></span><br><span class="line"></span><br><span class="line">ObjectAnimator.ofFloat(button,<span class="string">"alpha"</span>, <span class="number">1f</span>,<span class="number">0.2F</span>);       <span class="comment">//透明度</span></span><br></pre></td></tr></table></figure></p><p> <br><center><img src="/2016/11/25/Android动画/GIF1.gif"><img src="/2016/11/25/Android动画/GIF6.gif"></center><br></p><blockquote><h4 id="3-2-ValueAnimator"><a href="#3-2-ValueAnimator" class="headerlink" title="3.2 ValueAnimator"></a>3.2 ValueAnimator</h4></blockquote><p> ValueAnimator动画是ObjeecAnimator的父类，ObjeecAnimator的实现就是基于Value的，但是这两个类有什么区别呢？ObjeecAnimator主要是对属性的过渡操作，而Value则是对值的过渡操作。<br> 下面给一个ValueAnimator的例子，它实现了对Button的text的改变，还有对字体大小，宽度的改变，具体的可以看看注释。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">               ValueAnimator valueAnimator=ValueAnimator.ofInt(<span class="number">1</span>,<span class="number">100</span>);     <span class="comment">//一个区间</span></span><br><span class="line">               valueAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">                   IntEvaluator intEvaluator=<span class="keyword">new</span> IntEvaluator();   <span class="comment">//一个估值器</span></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator valueAnimator)</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//动画过程的监听方法</span></span><br><span class="line">                       <span class="keyword">int</span> i= (<span class="keyword">int</span>) valueAnimator.getAnimatedValue();   <span class="comment">//获取动画当前的值</span></span><br><span class="line">                       <span class="keyword">float</span> f=valueAnimator.getAnimatedFraction();   <span class="comment">//获取当前整个动画所占比例</span></span><br><span class="line">                       button.getLayoutParams().width=intEvaluator.evaluate(f,<span class="number">0</span>,<span class="number">600</span>);    <span class="comment">//按照当前比例计算出所占的值   f-比例   0-初始值  600-结束值</span></span><br><span class="line">                       button.setTextSize(i);   <span class="comment">//设置字体大小</span></span><br><span class="line">                       button.setText(i+<span class="string">""</span>);    <span class="comment">//设置值</span></span><br><span class="line">                       button.requestLayout();   <span class="comment">//当view确定自身已经不再适合现有的区域时，该view本身调用这个方法要求parent view重新调用他的onMeasure onLayout来对重新设置自己位置。</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               valueAnimator.setDuration(<span class="number">3000</span>).start();   <span class="comment">//设置过渡时间  启动</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><p>ValueAnimator不仅仅可以作用在改变控件上面，更多的是去改变对象的值。<br> <br><center><img src="/2016/11/25/Android动画/GIF2.gif"></center><br></p><blockquote><h4 id="3-3-AnimatorSet-这是一个动画的集合，能够同时做出集中不同的动画-看下面的例子"><a href="#3-3-AnimatorSet-这是一个动画的集合，能够同时做出集中不同的动画-看下面的例子" class="headerlink" title="3.3 AnimatorSet  这是一个动画的集合，能够同时做出集中不同的动画,看下面的例子"></a>3.3 AnimatorSet  这是一个动画的集合，能够同时做出集中不同的动画,看下面的例子</h4><p> <br><center><img src="/2016/11/25/Android动画/GIF3.gif"></center><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">play(Animator anim)：添加一个动画，并返回AnimatorSet.Builder </span><br><span class="line">playSequentially(List items)：添加一组动画，播放顺序为一一播放 </span><br><span class="line">playSequentially(Animator… items)：添加一组动画，播放顺序为一一播放 </span><br><span class="line">playTogether(Collection items)：添加一组动画，播放顺序为一起播放 </span><br><span class="line">playTogether(Animator… items)：添加一组动画，播放顺序为一起播放</span><br></pre></td></tr></table></figure></p></blockquote><p>很有意思。。</p><p> 最后看看需要注意的问题：<br>  <br><center><img src="/2016/11/25/Android动画/4.png"></center><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。&quot;&gt;&lt;a href=&quot;#安卓中的动画可以分为三种：View动画、帧动画、属性动画，下面我们来一种一种的来介绍。&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>github制作远程依赖库</title>
    <link href="https://zengwei123.github.io/2016/11/17/github%E5%88%B6%E4%BD%9C%E8%BF%9C%E7%A8%8B%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
    <id>https://zengwei123.github.io/2016/11/17/github制作远程依赖库/</id>
    <published>2016-11-17T09:58:13.000Z</published>
    <updated>2018-08-18T09:27:10.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法"><a href="#今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法" class="headerlink" title="今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法"></a>今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法</h4><p>首先先创建一个库工程，注意这个库工程是建立在项目里面的<br><br><center><img src="/2016/11/17/github制作远程依赖库/1.png"></center><br><br>然后配置<br><br><center><img src="/2016/11/17/github制作远程依赖库/2.png"></center><br><br>这里将zengwei123改成你的github用户名<br>apply plugin: ‘com.github.dcendents.android-maven’<br>group=’com.github.zengwei123’<br><br><center><img src="/2016/11/17/github制作远程依赖库/3.png"></center><br><br>classpath ‘com.github.dcendents:android-maven-gradle-plugin:2.1’<br><br><center><img src="/2016/11/17/github制作远程依赖库/4.png"></center><br><br>然后将你的项目上传github,上传之后点击<br><br><center><img src="/2016/11/17/github制作远程依赖库/5.png"></center><br><br>然后<br><br><center><img src="/2016/11/17/github制作远程依赖库/6.png"></center><br><br>输入信息<br><br><center><img src="/2016/11/17/github制作远程依赖库/7.png"></center><br><br>然后发布 ；<br>发布之后，打开网址 <a href="https://jitpack.io/" target="_blank" rel="noopener">https://jitpack.io/</a><br>在下面的输入框中输入你的仓库的url：如<a href="https://github.com/zengwei123/Curve" target="_blank" rel="noopener">https://github.com/zengwei123/Curve</a><br>如果你配置错了，那么就不是绿色的Get it。<br><br><center><img src="/2016/11/17/github制作远程依赖库/8.png"></center><br><br>滑到下面，会有一个这个<br><br><center><img src="/2016/11/17/github制作远程依赖库/9.png"></center><br><br>如果你一直是这一个样子的，那么就说明没有配置成功，他应该是：com.github.你的用户名:项目名:版本号，最后成功了，就可以在其他项目使用依赖的方式使用你的项目了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法&quot;&gt;&lt;a href=&quot;#今天写了一个控件，然后把它弄成了一个开源库，然后记录一下制作成开源库的方法&quot; class=&quot;headerlink&quot; title=&quot;今天写了一
      
    
    </summary>
    
      <category term="GitHub-Git" scheme="https://zengwei123.github.io/categories/GitHub-Git/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-事件分发机制</title>
    <link href="https://zengwei123.github.io/2016/11/05/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>https://zengwei123.github.io/2016/11/05/Android-事件分发机制/</id>
    <published>2016-11-05T02:28:00.000Z</published>
    <updated>2018-08-14T07:47:55.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事件分发主要分为2部分，View分发与ViewGroup，在了解事件分发的之前首先了解一下View与ViewGroup,View是没有子控件的，如Button,TextView等，但是ViewGroup是有子控件的，如ViewPager,RelativeLayout。</p></blockquote><p>首先看看View的事件分发，主要是两个方法dispatchTouchEvent和OnTouchEvent，从流程是从Activity-View，Activity的dispatchTouchEvent是事件分发的第一入口。<br><br><br>我们继承一个Button重写他的dispatchTouchEvent和OnTouchEvent<br><br><center><img src="/2016/11/05/Android-事件分发机制/2.png"></center><br><br>调用button的setOnTouchListener和setOnClickListener<br><br><center><img src="/2016/11/05/Android-事件分发机制/3.png"></center><br><br>重写activity的dispatchTouchEvent和OnTouchEvent<br><br><center><img src="/2016/11/05/Android-事件分发机制/4.png"></center><br><br>点击button,我们会看到下面这个Log打印顺序<br><br><center><img src="/2016/11/05/Android-事件分发机制/1.png"></center><br></p><blockquote><p>在这里你可能会奇怪为什么Activity的OnTouchEvent为什么没有调用，这是因为我们的Button在OnTouchEvent中已经处理了事件，最后执行的click，当我们将Button的OnTouchEvent返回值改为false,我们会看到下面的这中情况。<br>这时候Activity的OnTouchEvent就被调用了，因为我们在button的OnTouchEvent不处理事件，这样最后没人处理我们只能将事件返回给Activity，这样Activity的OnTouchEvent就会被调用</p></blockquote><p><br><center><img src="/2016/11/05/Android-事件分发机制/5.png"></center><br><br>这里我们看到最后没有执行click事件，并且UP也没有执行了，这是因为button在Down后没有处理事件，最后到了activity那里处理<br><br><center><img src="/2016/11/05/Android-事件分发机制/6.png"></center><br><br>如果我们在up的时候不处理，返回一个false<br><br><center><img src="/2016/11/05/Android-事件分发机制/7.png"></center><br><br>这样我们的Down和Up都执行但是最后的click没有执行，因为button没有处理事件，所以事件最后就到了Activity哪里，执行了OnTouchEvent<br><br><center><img src="/2016/11/05/Android-事件分发机制/8.png"></center><br><br>最后看书：<br><br><center><img src="/2016/11/05/Android-事件分发机制/9.png"></center><br><br><br><center><img src="/2016/11/05/Android-事件分发机制/10.png"></center><br><br><br><center><img src="/2016/11/05/Android-事件分发机制/11.png"></center><br></p><blockquote><p>下面来说说ViewGroup的分发事件，其实原理跟View差不多，只不过它多了一个onInterceptTouchEvent这个方法是用来控制事件是给自己消费还是分发给子控件。</p></blockquote><p><br><br>1.默认的onInterceptTouchEvent总是返回false的，就是不拦截touch事件，直接分发给了子控件。所以假如我们自定义了组合控件，譬如image+文字的组合控件，并且在activity里面注册监听期待点击它的时候会产生响应，那么我们就需要重写onInterceptTouchEvent了让它返回true，将事件拦截下来。</p><p>2.如果触摸的时候，我们只想出发ontouch监听，想屏蔽onclick监听的话，就需要在ontouch里面返回true就可以了</p><p>3.android事件分发是先传递到viewgroup，然后才传递到view的</p><p>4.子view如果将传递的事件消费处理掉，viewgroup当中是接收不到任何事件的</p><p>5.简单来讲，dispatchTouchEvent方法是为了onTouch监听的，onTouchEvent是为了onClick监听的。如果ontouch监听返回false，事件会传递到onTouchEvent当中触发onClick，如果是true的话就不会继续往下传递了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;事件分发主要分为2部分，View分发与ViewGroup，在了解事件分发的之前首先了解一下View与ViewGroup,View是没有子控件的，如Button,TextView等，但是ViewGroup是有子控件的，如ViewPager,Relat
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android常用控件-ViewPage</title>
    <link href="https://zengwei123.github.io/2016/10/29/Android%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6-ViewPage/"/>
    <id>https://zengwei123.github.io/2016/10/29/Android常用控件-ViewPage/</id>
    <published>2016-10-29T10:07:03.000Z</published>
    <updated>2018-08-13T11:52:00.909Z</updated>
    
    <content type="html"><![CDATA[<p>ViewPage是我们非常常用的控件，他的功能就是多视图的切换</p><blockquote><p>ViewPage<br>    <strong>·</strong> ViewPage他继承了ViewGroup,所以他是一个容器类，可以在其中添加其他的View。<br>    <strong>·</strong> ViewPage需要一个Adatper来给他提供数据<br>    <strong>·</strong> ViewPage经常与Fragment和TabLayout一起使用</p></blockquote><p>使用ViewPage+TabLayout<br>首先看看布局,这个就是一个最基本的ViewPage+TabLayout的布局了，可能TabLayout需要额外导入<strong>compile ‘com.android.support:design:26.1.0’</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    </span><br><span class="line">android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">android:layout_height=&quot;match_parent&quot;&gt;    </span><br><span class="line">&lt;android.support.design.widget.TabLayout        </span><br><span class="line">android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">android:layout_height=&quot;wrap_content&quot;        </span><br><span class="line">android:id=&quot;@+id/tabLayout&quot;&gt;</span><br><span class="line">&lt;/android.support.design.widget.TabLayout&gt;    </span><br><span class="line">&lt;android.support.v4.view.ViewPager        </span><br><span class="line">android:id=&quot;@+id/viewpager&quot;        </span><br><span class="line">android:layout_width=&quot;match_parent&quot;        </span><br><span class="line">android:layout_height=&quot;match_parent&quot;        </span><br><span class="line">android:layout_below=&quot;@+id/tabLayout&quot;&gt;    </span><br><span class="line">&lt;/android.support.v4.view.ViewPager&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>然后看看Fragment的代码，很简单的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View view=inflater.inflate(R.layout.activity_main,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后编写ViewPage的适配器，注意重写<strong>getPageTitle(int position)</strong>这个方法是用来设置TabLayout的title的，因为TabLayout是跟ViewPager绑定起来的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myViewPageAdatper</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;    </span><br><span class="line"><span class="keyword">private</span> List&lt;MyFragment&gt; myFragments;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">myViewPageAdatper</span><span class="params">(FragmentManager fm, List&lt;MyFragment&gt; fragments)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">super</span>(fm);        </span><br><span class="line"><span class="keyword">this</span>.myFragments=fragments;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">return</span> myFragments.get(position);    </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;        </span><br><span class="line"><span class="keyword">return</span> myFragments.size();    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;        </span><br><span class="line"><span class="keyword">return</span> <span class="string">"标题："</span>+position;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是ViewPage的设置<br><br><center><img src="/2016/10/29/Android常用控件-ViewPage/1.png"></center><br><br>最后的效果<br><br><center><img src="/2016/10/29/Android常用控件-ViewPage/GIF.gif"></center><br><br>对于ViewPage我们的程序有各种各样的需求，有时候我们需要他不能够滑动<br>这是我们可以设置setOnTouchListener()返回值为true，根据事件分发机制，在onTouch中的DOWN事件时候，将事件拦截。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">viewpager.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>这样子是可以实现，但是如果ViewPager的Fragment里面有可以滑动的控件，比如又一个ViewPager,这样我们上面的那种办法就没有用了viewPager还是可以被拖出来，对于这种情况我们只有继承ViewPager来重新分发它的事件，禁止它的滑动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZwViewPage</span> <span class="keyword">extends</span> <span class="title">ViewPager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isScroll;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZwViewPage</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZwViewPage</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.dispatchTouchEvent一般情况不做处理</span></span><br><span class="line"><span class="comment">     *,如果修改了默认的返回值,子孩子都无法收到事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);   <span class="comment">// return true;不行</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否拦截</span></span><br><span class="line"><span class="comment">     * 拦截:会走到自己的onTouchEvent方法里面来</span></span><br><span class="line"><span class="comment">     * 不拦截:事件传递给子孩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return false;//可行,不拦截事件,</span></span><br><span class="line">        <span class="comment">// return true;//不行,孩子无法处理事件</span></span><br><span class="line">        <span class="comment">//return super.onInterceptTouchEvent(ev);//不行,会有细微移动</span></span><br><span class="line">        <span class="keyword">if</span> (isScroll)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否消费事件</span></span><br><span class="line"><span class="comment">     * 消费:事件就结束</span></span><br><span class="line"><span class="comment">     * 不消费:往父控件传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//return false;// 可行,不消费,传给父控件</span></span><br><span class="line">        <span class="comment">//return true;// 可行,消费,拦截事件</span></span><br><span class="line">        <span class="comment">//super.onTouchEvent(ev); //不行,</span></span><br><span class="line">        <span class="comment">//虽然onInterceptTouchEvent中拦截了,</span></span><br><span class="line">        <span class="comment">//但是如果viewpage里面子控件不是viewgroup,还是会调用这个方法.</span></span><br><span class="line">        <span class="keyword">if</span> (isScroll)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 可行,消费,拦截事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScroll</span><span class="params">(<span class="keyword">boolean</span> scroll)</span> </span>&#123;</span><br><span class="line">        isScroll = scroll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样子我们就实现了禁止ViewPager的滑动，下面我们来说说ViewPager的预加载。<br>ViewPager会默认加载当前页和当前页的左右两页。<br>一开始当前页是下标0，所以一开始默认加载第0页（指下标，下同）和第1页。<br>当你向右滑动，当前页为第1页时，ViewPager会加载第2页，这时一共有3页存在（第0,1,2页）。<br>再向右滑动，当前页为第2页时，会移除第0页，加载第3页，同理向左滑动当前页为第1页时，会移除第3页。<br>我们可以设置下面的这个方法来预加载多个页面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewpager.setOffscreenPageLimit(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure></p><p>但是如果我们不想要他预加呢？当每个fragment都需要去联网加载网络数据或者做一些耗时的操作，而且有其他的fragment并不是必须的，用户不一定会打开。<br>这样的话如果还预加载的话将会浪费资源，用户体验也不好。<br>虽然可以通过setOffscreenPageLimit(0)来设置不提前预加载，但这样的设置没有效果。通过研究ViewPager的源码，可以设置该类默认的DEFAULT_OFFSCREEN_PAGES = 0，来预防预加载。<br>还有一直办法就是判断fragment的位置是否为当前显示ViewPager，如果是就加载，不是的话就不给加载<br><br><br>设置ViewPager默认显示的页面,通过这个方法就可以通过代码设置页面的切换了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewPager.setCurrentItem(2)</span><br></pre></td></tr></table></figure></p><p>如果想要下面这种效果<br><br><center><img src="/2016/10/29/Android常用控件-ViewPage/GIF1.gif"></center><br><br>在布局文件中色湖之<strong>ClipToPadding=“false”</strong>然后设置padding,就可以实现了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ViewPage是我们非常常用的控件，他的功能就是多视图的切换&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ViewPage&lt;br&gt;    &lt;strong&gt;·&lt;/strong&gt; ViewPage他继承了ViewGroup,所以他是一个容器类，可以在其中添加其他的View。&lt;br
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android随笔-Fragment</title>
    <link href="https://zengwei123.github.io/2016/10/18/Android-Fragment/"/>
    <id>https://zengwei123.github.io/2016/10/18/Android-Fragment/</id>
    <published>2016-10-18T08:09:07.000Z</published>
    <updated>2018-08-13T06:55:18.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一-Fragment简介："><a href="#一-Fragment简介：" class="headerlink" title="一.Fragment简介："></a>一.Fragment简介：</h4><p>Android在3.0中引入了Fragments的概念，主要目的是用在大屏幕设备上–例如平板电脑上，支持更加动态和灵活的UI设计。平板电脑的屏幕要比手机的大得多，有更多的空间来放更多的UI组件,并且这些组件之间会产生更多的交互。Fragment允许这样的一种设计，而不需要你亲自来管理View Hierarchy的复杂变化。通过将Activity的布局分散到Fragment中，你可以在运行时修改Activity的外观，并在由Activity管理的Back Stack中保存那些变化。</p></blockquote><p><strong>其实这只是比较官方一点的说法,其实通俗易懂点说就是,一个可以将activity拆分成几个完全独立封装的可重用的组件，每个组件有自己的生命周期和ui布局。它可以表示Activity中的行为或用户界面部分。我们可以在一个Activity中用多个Fragment组合来构建多窗格的UI，以及在多个Activity中重复使用某个Fragment。它有自己的生命周期，能接受自己的输入，并且可以在 Activity 运行时添加或删除Fragment（有点像在不同 Activity 中重复使用的“子 Activity”）。</strong></p><blockquote><h4 id="二-Fragment生命周期："><a href="#二-Fragment生命周期：" class="headerlink" title="二.Fragment生命周期："></a>二.Fragment生命周期：</h4><ul><li>onAttach() : Fragment和Activity建立关联的时候调用，被附加到Activity中去。</li><li>onCreate() : 系统会在创建Fragment时调用此方法。可以初始化一段资源文件等等。</li><li>onCreateView() : 系统会在Fragment首次绘制其用户界面时调用此方法。要想为Fragment绘制UI，从该方法中返回的View必须是Fragment布局的根视图。如果Fragment未提供UI，您可以返回null。</li><li>onViewCreated() : 在Fragment被绘制后，调用此方法，可以初始化控件资源。</li><li>onActivityCreated() : 当onCreate onCreateView()，onViewCreated()方法执行完后调用，也就是Activity被渲染绘制出来后。</li><li>onStart() : 当系统调用该方法的时候，fragment已经显示在ui上，但还不能进行互动，因为onResume方法还没执行完。</li><li>onResume() : 该方法为fragment从创建到显示Android系统调用的最后一个生命周期方法，调用完该方法时候，fragment就可以与用户互动了。</li><li>onPause() : 系统将此方法作为用户离开Fragment的第一个信号（但并不总是意味着此Fragment会被销毁）进行调用。 通常可以在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</li><li>onStop() : 当onStop返回的时候，fragment将从屏幕上消失。</li><li>onDestoryView() : 该方法的调用意味着在 onCreateView 中创建的视图都将被移除。</li><li>onDestroy() : Android在Fragment不再使用时会调用该方法，要注意的是这时Fragment还和Activity相关联的！并且可以获得Fragment对象，但无法对获得的Fragment进行任何操作。</li><li>onDetach() : 为Fragment生命周期中的最后一个方法，当该方法执行完后，Fragment与Activity不再有关联。</li></ul></blockquote><p>顺序如图下：<br><br><center><img src="/2016/10/18/Android-Fragment/cycle.png"></center><br></p><blockquote><h4 id="三-Fragment与Activity关系："><a href="#三-Fragment与Activity关系：" class="headerlink" title="三.Fragment与Activity关系："></a>三.Fragment与Activity关系：</h4><p>总的来说，Fragment和Activity的生命周期类似。需要注意的是，它相比于Activity，多了onAttach(), onCreateView(), onActivityCreate)和onDestoryView()、onDetach()这几个回调函数；但是，却少了onRestart()。</p><ul><li>onAttach(Activity) : 当Fragment和Activity发生关联时使用</li><li>onCreateView(LayoutInflater, ViewGroup, Bundle) : 创建该Fragment的视图</li><li>onActivityCreate(Bundle) : 当Activity的onCreate方法返回时调用</li><li>onDestoryView() : 与onCreateView相对应，当该Fragment的视图被移除时调用</li><li>onDetach() : 与onAttach相对应，当Fragment与Activity关联被取消时调用</li></ul></blockquote><p>关系图如下：<br><br><center><img src="/2016/10/18/Android-Fragment/comparison.png"></center><br><br><strong>注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现。</strong></p><blockquote><h4 id="四-总结："><a href="#四-总结：" class="headerlink" title="四.总结："></a>四.总结：</h4><p><strong>在用法的代码部分参考郭神的博客，感觉郭神在代码讲解部分通俗易懂，看起来也方便。总之，在使用Fragment也有一些注意事项，不是那么完美的，虽然谷歌推荐我们用Fragment来代替Activity来使用，我们也确实这做了，现在基本主流的APP也都是少量Activity+很多Fragment，但也需要避免有些坑慎入。</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一-Fragment简介：&quot;&gt;&lt;a href=&quot;#一-Fragment简介：&quot; class=&quot;headerlink&quot; title=&quot;一.Fragment简介：&quot;&gt;&lt;/a&gt;一.Fragment简介：&lt;/h4&gt;&lt;p&gt;Android在3.0中引
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android消息机制-Handler</title>
    <link href="https://zengwei123.github.io/2016/10/13/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler/"/>
    <id>https://zengwei123.github.io/2016/10/13/Android消息机制-Handler/</id>
    <published>2016-10-13T06:53:50.000Z</published>
    <updated>2018-08-13T10:24:03.406Z</updated>
    
    <content type="html"><![CDATA[<p> 安卓中的消息机制说的其实就不同线程间的通讯，就是Handler。<br>  <br><br> <strong>为什么安卓中要有消息机制？</strong><br> 因为在安卓中更新UI是必须在子线程中，UI控件部署线程安全的，如果多线程并发访问就会出现问题。<br>  <br><br> <strong>你可能要问为什么不给UI控件加上锁呢</strong>？<br> 这是因为上锁之后会让UI变得复杂同时效率变低，还会阻塞某些进程的执行，所以UI采用单线程模式，这对开发者也不是很麻烦，只要通过Handler就能够解决。<br> <br></p><h3 id="下面就是Handler的基本用法，在子线程中跟新UI"><a href="#下面就是Handler的基本用法，在子线程中跟新UI" class="headerlink" title="下面就是Handler的基本用法，在子线程中跟新UI"></a>下面就是Handler的基本用法，在子线程中跟新UI</h3><p> <br><center><img src="/2016/10/13/Android消息机制-Handler/GIF1.gif"></center><br><br> <br><center><img src="/2016/10/13/Android消息机制-Handler/1.png"></center><br><br> 这个就是Handler的基本用法。<br>  <br></p><h3 id="消息机制的分析"><a href="#消息机制的分析" class="headerlink" title="消息机制的分析"></a>消息机制的分析</h3><p>  安卓的消息机制就是Handler机制，在handler机制中有两个很重要的东西，一个是Looper、另一个是MessageQueue,这两个东西和Handler凑成了Android中的非常重要的消息机制。<br>  <br><br>  他的原理是这样的：<br>  1、Handler创建一个消息，将这个消息插入到MessageQueue中。<br>  2、Looper不断轮询MessageQueue的next方法。<br>  3、Looper发现有消息（Message）了,就调用回调方法handlerMessage。<br>  我们常常用Handler来进行更新UI但是这并不是说它只能够跟新UI，如同读取文件，网络请求等耗时操作都可以在Handler里面来进行的。<br><br><br>通过上面的原理我们了解需要有一个消息队列MessageQueue，那么这个消息队列是从哪里来的呢？这里我们就要看到Looper，这个类的构造方法中创建了MessageQueue,然后将当前线程的对象保存起来。<br> <br><center><img src="/2016/10/13/Android消息机制-Handler/2.png"></center><br><br> 而我们的Handler的创建也不能离开Looper,如果new一个Handler但是他没有Looper的话就会报错，可能你这里你就有疑问了，我们在上面的更新UI的实例中并没有看到哪里有Looper,<strong>这是因为我们的UI线程在创建的时候就会创建一个Looper</strong>,当我们如果在子线程new一个Handle就会出现保存，所以我们要主动去创建一个Lopper。<br> <br><br> Lopper的几个方法<br> 1、Looper.prepare():为当前线程创建一个Looper<br> 2、Looper.loop():开启消息轮询<br> 3、Looper.myLooper.quit():直接退出Looper<br> 4、Looper.myLooper.quitSafely():设定一个标记，只有当目前已有的消息处理完才会执行退出操作。<br> 当Looper退出之后，Handler就无法发送消息，当Looper退出后，Handler就无法发送消息，send出去的消息会返回false；当我们在子线程中创建了Looper并且所有的消息都处理完毕的时候，要记得调用quit方法，不让这个Looper就一直处于阻塞状态一直那么等待下去，同时主线程的Looper是无法退出的。<br>  <br><br> 我们看看Looper的loop()方法的源码<br> <br><center><img src="/2016/10/13/Android消息机制-Handler/3.png"></center><br><br> 通过代码我们知道：looper方法是一个死循环，唯一跳出的循环的方式是MessageQueue的next方法返回null，但是基本上是不可能的。如果我们不手动调用quit或者quitSafely方法的话，MessageQueue的next方法是不可能返回null的。因为当MessageQueue没有消息时，next方法会一直阻塞在那里，因为MessageQueue的next方法阻塞了，就导致Looper的loop方法也一直在阻塞了。这里我们那一分为二的谈，loop轮询不到消息：那么处于阻塞状态，然后就没有然后了，除了又轮询到了新的消息loop轮到了新的消息：Looper就会处理消息1、msg.target.dispatchMessage(msg)，这里的 msg.targe就是指Handler对象2、一圈下来，Handler发送的消息有交给了自己的dispatchMessage方法来处理了。（这个dispatchMessage方法不是Handler自己调用时，是与Handler相相关的Looper简介调用的），这样下来，就成功地将逻辑切换到指定的线程当中去了<br>  <br><br>  Handler的主要工作就是接受和发送<br>  下面是发送的方法，主要有两种post,send;<br>   <br><center><img src="/2016/10/13/Android消息机制-Handler/4.png"></center><br><br><br><center><img src="/2016/10/13/Android消息机制-Handler/5.png"></center><br><br>而我们接收的方法：<br>dispatchMessage方法<br>dispatchMessage会判断三种情况</p><p>1、如果是post发送来的message，那么就让这个message所持有的Runnable执行run方法，非常简单。<br>Message的Callback 是一个Runnable对象，Handler的post的重载的函数不管参数多少，肯定都是有Runnable的。</p><pre><code>private static void handleCallback(Message message) {    message.callback.run();}</code></pre><p>2、如果是利用Handler(Callback callback) 构造函数实例化的Handler，也就是构造函数里面传入了一个CallBack的对象，那么就执行这个Callback的handlerMessage。<br>利用这个接口和Handler的一个构造函数，我们可以这么创建Handler handler=new Handler(callback)来创建Handler;备注写明了这个接口的作用：可以创建一个Handler的实例但是不需要派生Handler的子类。对比我们日常中最经常做的，就是派生一个Handler的子类，复写handleMessage方法，而通过上面的代码，我们有了一种新的创建Handler方式，那就是不派生子类，而是通过Callback来实现。</p><p>这种方式非常少用。</p><p>看一下Handler里面的Callback这个接口的设计<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、如果是send方法发送的，那么就执行handleMessage，这个方法我们非常熟悉了，google的给的备注的也说了，子类必须实现方法以接受这些Message。这也就是我们最常见的最常用的方式了。</p><pre><code class="java"><span class="comment">/**</span><span class="comment"> * Subclasses must implement this to receive messages.</span><span class="comment"> */</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{}</code></pre><blockquote><p>参考：<a href="https://www.jianshu.com/p/9e4d1fab0f36" target="_blank" rel="noopener">https://www.jianshu.com/p/9e4d1fab0f36</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 安卓中的消息机制说的其实就不同线程间的通讯，就是Handler。&lt;br&gt;  &lt;br&gt;&lt;br&gt; &lt;strong&gt;为什么安卓中要有消息机制？&lt;/strong&gt;&lt;br&gt; 因为在安卓中更新UI是必须在子线程中，UI控件部署线程安全的，如果多线程并发访问就会出现问题。&lt;br&gt;  &lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android-如何在子线程中更新UI</title>
    <link href="https://zengwei123.github.io/2016/10/07/Android%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9B%B4%E6%96%B0UI/"/>
    <id>https://zengwei123.github.io/2016/10/07/Android如何在子线程中更新UI/</id>
    <published>2016-10-07T01:27:16.000Z</published>
    <updated>2018-08-13T08:46:36.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="一-前言："><a href="#一-前言：" class="headerlink" title="一.前言："></a>一.前言：</h4><p>项目开发中会涉及到一些耗时操作，这个时候就会开启一个子线程，将耗时操作放到子线程中取操作，操作完毕后，往往还要同步更新ui，这个时候如果直接在子线程中更新ui，将会导致程序的闪退，同时还会看到如下报错</p></blockquote><p><strong>android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</strong><br>意思是：只有创建视图层次结构的原始线程才能触及它的视图，其实说白了就是在子线程不能做更新UI的操作。</p><blockquote><h4 id="二-解决方法："><a href="#二-解决方法：" class="headerlink" title="二.解决方法："></a>二.解决方法：</h4><ul><li>第一种方式 : runOnUiThread</li><li>第二种方式 : view.post();</li><li>第三种方式 : Handler.post();</li></ul></blockquote><blockquote><p><strong>第一种方式 : runOnUiThread </strong><br><br><center><img src="/2016/10/07/Android如何在子线程中更新UI/toupdate.png"></center><br></p></blockquote><blockquote><p><strong>第二种方式 : view.post(); </strong><br><br><center><img src="/2016/10/07/Android如何在子线程中更新UI/toupdate_1.png"></center><br></p></blockquote><blockquote><p><strong>第三种方式 : Handler.post(); </strong><br><br><center><img src="/2016/10/07/Android如何在子线程中更新UI/toupdate_2.png"></center><br></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;一-前言：&quot;&gt;&lt;a href=&quot;#一-前言：&quot; class=&quot;headerlink&quot; title=&quot;一.前言：&quot;&gt;&lt;/a&gt;一.前言：&lt;/h4&gt;&lt;p&gt;项目开发中会涉及到一些耗时操作，这个时候就会开启一个子线程，将耗时操作放到子线程中取操作，
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android侧滑布局-DrawerLayout</title>
    <link href="https://zengwei123.github.io/2016/09/26/Android%E4%BE%A7%E6%BB%91%E5%B8%83%E5%B1%80-DrawerLayout/"/>
    <id>https://zengwei123.github.io/2016/09/26/Android侧滑布局-DrawerLayout/</id>
    <published>2016-09-26T03:54:14.000Z</published>
    <updated>2018-08-07T07:42:27.676Z</updated>
    
    <content type="html"><![CDATA[<p>DrawerLayout是谷歌官方推出的侧滑菜单,DrawerLayout最好为界面的根布局，否则可能会出现触摸事件被屏蔽的问题；主内容区的布局代码要放在侧滑菜单布局的前面, 因为 XML 顺序意味着按 z序（层叠顺序）排序，并且抽屉式导航栏必须位于内容顶部；侧滑菜单部分的布局必须设置<strong>layout_gravity</strong>属性，他表示侧滑菜单是在左边还是右边，而且如果不设置在的时候会报错，设置了<strong>layout_gravity=”start/left”</strong>的视图才会被认为是侧滑菜单,<strong>同时侧滑的布局必须放在最下面</strong>，不然无法响应侧滑控件的的事件，只会点击之后就关闭侧滑<br><br><center><img src="/2016/09/26/Android侧滑布局-DrawerLayout/1.png"></center><br><br>drawerLayout左侧菜单（或者右侧）的展开与隐藏可以被DrawerLayout.DrawerListener的实现监听<br><br><center><img src="/2016/09/26/Android侧滑布局-DrawerLayout/2.png"></center><br><br>我们还可以通过按钮显示侧边栏<br><br><center><img src="/2016/09/26/Android侧滑布局-DrawerLayout/3.png"></center><br><br>侧滑的布局可以写在fragment,这里<strong>name</strong>属性就是用来对应的Fragment的<br><br><center><img src="/2016/09/26/Android侧滑布局-DrawerLayout/4.png"></center><br><br><br><center><img src="/2016/09/26/Android侧滑布局-DrawerLayout/5.png"></center><br><br>经过这几步我们就吧侧滑菜单写出来了<br>在这里 <code>drawer_layout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED,Gravity.END);</code> 锁定右面的侧滑菜单，不能通过手势关闭或者打开，只能通过代码打开！<br>如果DrawerLayout侧滑菜单中的控件点击事件能穿透到底部,那么可以在菜单的布局文件中设置<code>clickable=&quot;true&quot;</code>如果想实现QQ那种底部布局跟则动的效果就在addDrawerListener事件中的onDrawerSlide()添加下面的代码,就能跟随移动了</p><pre><code>//mDrawerLayout为你的DrawerLayoutView content = mDrawerLayout.getChildAt(0);int offset = (int) (drawerView.getWidth() * slideOffset);content.setTranslationX(offset);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DrawerLayout是谷歌官方推出的侧滑菜单,DrawerLayout最好为界面的根布局，否则可能会出现触摸事件被屏蔽的问题；主内容区的布局代码要放在侧滑菜单布局的前面, 因为 XML 顺序意味着按 z序（层叠顺序）排序，并且抽屉式导航栏必须位于内容顶部；侧滑菜单部分的
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android四大组件之Service</title>
    <link href="https://zengwei123.github.io/2016/09/19/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BService/"/>
    <id>https://zengwei123.github.io/2016/09/19/Android四大组件之Service/</id>
    <published>2016-09-19T02:58:12.000Z</published>
    <updated>2018-08-07T03:38:39.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-Service作用："><a href="#1-Service作用：" class="headerlink" title="1.Service作用："></a>1.Service作用：</h4></blockquote><p>提供需要长期在后台长期运行的服务（如复杂计算、下载等），主要是因为它没有长的生命周期、没有用户界面、在后台运行。</p><blockquote><h4 id="2-Service分类："><a href="#2-Service分类：" class="headerlink" title="2.Service分类："></a>2.Service分类：</h4></blockquote><p><strong>本地</strong>：运行在主线程，主线程终止后服务也会终止。但是能够节约资源，并且通信方便，由于在同一进程不需要IPC和AIDL，主要使用在需要依附某个进程的服务，音乐播放等。<br><strong>远程</strong>：运行在独立进程，常驻在后台，不受其他Activity影响但是非常消耗资源，通讯需要比较复杂，主要使用在系统级别的服务。<br><strong>前台</strong>：通知栏可以显示出来，用户可以看到，主要使用在需要让用户只要并进行相关操作，如音乐播放。<br><strong>后台</strong>：主要是用户无法看到，主要使用在不需要让用户知道的一些操作，跟新数据，同步数据等</p><blockquote><h4 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h4></blockquote><p><strong>·</strong> 如果Service是第一次启动先会执行 <strong>onCreate(),onStartCommand()</strong><br><strong>·</strong> 当次启动Service调用，将只执行<strong>onStartCommand()</strong>，因为此时Service已经创建了，无需执行<strong>onCreate()</strong>回调。无论多少次的启动Service，只需要一次<strong>stopService()</strong>即可将此Service终止，执行<strong>onDestroy()</strong>函数。<br><strong>· onStartCommand(..)</strong>可以多次被调用，<strong>onDestroy()与onCreate()</strong>相匹配，当用户强制kill掉进程时，<strong>onDestroy()</strong>是不会执行的。<br><strong>· startService(Intent serviceIntent)</strong>，其中的intent既可以是显式Intent，也可以是隐式Intent，当Client与Service同处于一个App时，一般推荐使用显示Intent。当处于不同App时，只能使用隐式Intent。<br><strong>·</strong> 当Service需要运行在单独的进程中，<strong>AndroidManifest.xml</strong>声明时需要通过<strong>android:process</strong>指明此进程名称，当此Service需要对其他App开放时，<strong>android:exported</strong>属性值需要设置为true.</p><blockquote><h4 id="4-通讯"><a href="#4-通讯" class="headerlink" title="4.通讯"></a>4.通讯</h4></blockquote><ol><li>简单通信<br>直接通过Intent进行传值，我们在启动一个Service的时候通过Intent的对象向Service进行传值，这种方式传递值比较不方便，性能不是很高。<br>传值：<br><br><center><img src="/2016/09/19/Android四大组件之Service/1.png"></center><br><br>获取值：<br><br><center><img src="/2016/09/19/Android四大组件之Service/2.png"></center><br></li></ol><p>2．绑定服务传输数据<br>    在Service中编写Binder的内部类，自定义方法进行数据传输。<br>活动类：<br><br><center><img src="/2016/09/19/Android四大组件之Service/3.png"></center><br><br>服务类：<br><br><center><img src="/2016/09/19/Android四大组件之Service/4.png"></center><br></p><ol start="3"><li>通过使用Messenger方式（可以在不同进程间通讯）<br>服务端：<br><br><center><img src="/2016/09/19/Android四大组件之Service/5.png"></center><br><br>客户端<br><br><center><img src="/2016/09/19/Android四大组件之Service/6.png"></center><br></li></ol><blockquote><h4 id="5-服务单独运行在进程"><a href="#5-服务单独运行在进程" class="headerlink" title="5.服务单独运行在进程"></a>5.服务单独运行在进程</h4></blockquote><p>在XML文件中给Service添加process属性，有两种赋值方式，一种是[:xxxxx],一种是[com.pw.xxx.xxx]  第一种赋值是一种简写，完整的写法是[com.xxx.xxx:xxxx]这样的进程是应用的私有进程，其他应用不会跟它跑到同一个地方去。而第二种就是一种全局进程，其他的应用程序可以通过ShareUID跑进去。<br>多进程的使用地方，可以使用在一些需要保活的地方，音乐后台播放，在退出activity后还能继续播放、加载大图、推送服务，能够在程序退出后继续的向用户推送东西。将功能独立的分开来，减少程序崩溃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-Service作用：&quot;&gt;&lt;a href=&quot;#1-Service作用：&quot; class=&quot;headerlink&quot; title=&quot;1.Service作用：&quot;&gt;&lt;/a&gt;1.Service作用：&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;提供需
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android四大组件之Activity</title>
    <link href="https://zengwei123.github.io/2016/09/15/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity/"/>
    <id>https://zengwei123.github.io/2016/09/15/Android四大组件之Activity/</id>
    <published>2016-09-15T01:09:23.000Z</published>
    <updated>2018-08-07T02:59:42.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-正常的周期"><a href="#1-正常的周期" class="headerlink" title="1.正常的周期"></a>1.正常的周期</h4></blockquote><p>OnCreate: 生命周期的第一个方法，可以做一些初始化的操作<br>onRestart: 表示activit正在重新启动，这一般是当activity从不可见变成可见时调用，一般是由用户行为导致<br>OnStart:这是说明activity正在被启动，即将开始。<br>OnResume:表示activity已经可以看见了，并且出现在前台，已经与用户进行交互了。在这里OnStart和OnResume都是出现已经可见了，但是OnStart还在后台而OnResume已经出现在了前台<br>OnPause:表示activity正在停止，这个时候OnStop马上回被调用，在这里已经进行一些数据存储，动画显示等不耗时的操作，因为OnPause要执行完才能执行其他activity的OnResume。<br>OnStop:表示activity即将停止，在这里可以做一些资源比较有重量的回收，但是也不能太过耗时。<br>OnDestroy:最后一个方法，表示activity活到头了，在这里可以做一些回收工作和资源释放</p><p>OnStart和OnResume、OnPause和OnStop这两对方法没有什么实质性的不同，OnResume是可见周期的最后一个方法已经结束了，OnStart是还正在启动，OnPauses要执行完之后才能执行新activity的方法，OnStop是结束周期中简的一个</p><blockquote><h4 id="2-异常的生命周期"><a href="#2-异常的生命周期" class="headerlink" title="2.异常的生命周期"></a>2.异常的生命周期</h4></blockquote><p>1、资源相关的系统配置发生改变导致<strong>activity</strong>被杀死重建<br>竖屏时变成横屏，由于设置了不同资源图片，<strong>activity</strong>会销毁重建。他会执行<br><strong>onPause</strong>→<strong>onSaveInstanceState</strong>→<strong>onStop</strong>→<strong>onDestroy</strong><br>然后<br><strong>onCreate</strong>→<strong>onStart</strong>→<strong>onResume</strong><br><strong>onSaceInstanceState</strong>是在异常结束<strong>activity</strong>时才会执行的方法，他会保存当前<strong>activity</strong>的状态同时会在新创建的<strong>activity</strong>调用<strong>onRestoreInstanceState</strong>方法并且将<strong>onSaceInstanceState</strong>方法保存的bundle传递给<strong>onCreate</strong>。我们可以在<strong>onSaceInstanceState</strong>中存储一些数据，在<strong>onRestoreInstanceState</strong>或者<strong>onCreate</strong>中读取，有一点<strong>onRestoreInstanceState</strong>如果执行那么<strong>Bundle</strong>是不会为空的，但是<strong>onCreate</strong>中就不知道了</p><p>2、资源不足导致优先级低的<strong>activity</strong>被杀死<br>优先级：前台<strong>activity</strong><br>        可见非前台<strong>activit</strong>（比如弹出一个对话框）<br>        后台<strong>activit</strong><br>杀死activity后，就会在有内存的时候通过<strong>onSaceInstanceState</strong> 保存<strong>onRestoreInstanceState</strong>恢复<br>可以通过设置<strong>android：configChanges=”orientation”</strong>  静止重建</p><blockquote><h4 id="3-Activity启动模式"><a href="#3-Activity启动模式" class="headerlink" title="3.Activity启动模式"></a>3.Activity启动模式</h4></blockquote><p>1、存在的意义：<br>多次启动同一个<strong>activity</strong>，多次创建同一个实例，这是很傻的行为<br>1.<strong>standard</strong>（默认）每次启动<strong>activity</strong>都会重新创建实例<br>2.<strong>singleTop</strong>（栈顶复用模式）  判断<strong>activity</strong>是否在任务栈顶，如果在直接引用，同时调用<strong>onNewIntent</strong>方法，如果不在就创建新的实例。<br>3.<strong>singleTask</strong>（栈内复用模式） 判断栈中是否有这个实例，如果有那么就使用这个实例，如果没有那么就创建一个，这个<strong>activity</strong>会调用<strong>onNewIntent</strong><br>4.<strong>singleInstance</strong>（单实例模式）这个是 <strong>singleTask</strong> 模式的加强版，它除了具有 <strong>singleTask</strong> 模式的所有特性外，它还有一点独特的特性，那就是此模式的 <strong>Activity</strong> 只能单独地位于一个任务栈，不与其他 <strong>Activity</strong> 共存于同一个任务栈。</p><p>2、什么是任务栈：<br>这是一个<strong>activity</strong>的参数<strong>TaskAffinity</strong>,这个参数标识了<strong>activity</strong>所需要的任务栈，默认情况下任务栈的名字为包名，我们可以给每个<strong>activity</strong>命一个名字，同名的是名字就是在一个任务栈，它主要是和<strong>singleTask</strong>或者<strong>allowTaskReparenting</strong>结合使用。<br>在<strong>TaskAffinity</strong>和<strong>allowTaskRepaernting</strong>一起使用且<strong>allowTaskRepaernting</strong>为<strong>true</strong>的时候如果当一个应用A的<strong>activity</strong>启动了一个应用B的<strong>activity</strong>，那么这个B应用的<strong>activity</strong>会直接从A的任务栈跑到B的任务栈。当返回桌面，点击应用B，他不会启动住<strong>activity</strong>，而会显示应用A启动的<strong>acitivity</strong></p><p>设置启动模式有两种方法：<br>1.通过<strong>launchMode</strong>指定<br>2.通过<strong>Intent.addFlage</strong>指定<br>第二种的优先级比第一种要高，第二种无法指定为第四种模式</p><p>3、Activity隐式调用<br>隐式调用能够设置一些过滤信息，如果不匹配将无法启动<strong>activity</strong>。<br>需要匹配：<strong>action、category、data</strong><br>Action：是一个字符串，这里指定匹配是字符串相同，在xml文件中如过指定了<strong>action</strong>，如果在<strong>intent</strong>中没有设置，那么是无法匹配成功的，想要匹配必须<strong>intent</strong>中的字符串与<strong>action</strong>的字符串相同。<br><strong>Category：Category</strong>中必须要有一个<strong>android.intent.Category.DEFAULT</strong>,而且intent可以不指定<strong>Category</strong>。<br>Date:规则跟action一样，如果定义了那么就要指定，Date主要是一个规则，用来放置url</p><p>我们还可以在配置文件的activity中设置android:screenOrientation属性来设置他的横竖屏显示portrait（竖屏），landscape （横屏）</p><p>全屏的 Activity<br>要使一个 Activity 全屏运行，可以在其 onCreate()方法中添加如下代码实现：</p><pre><code>// 设置全屏模式getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏requestWindowFeature(Window.FEATURE_NO_TITLE);</code></pre><blockquote><h4 id="4-使用-Intent-通信"><a href="#4-使用-Intent-通信" class="headerlink" title="4.使用 Intent 通信"></a>4.使用 Intent 通信</h4></blockquote><p>在 Android 中，不同的 Activity 实例可能运行在一个进程中，也可能运行在不同的进程中。因此我们需要一种特别的机制帮助我们在 Activity 之间传递消息。Android 中通过 Intent 对象来表示一条消息，一个 Intent 对象不仅包含有这个消息的目的地，还可以包含消息的内容，这好比一封 Email，其中不仅应该包含收件地址，还可以包含具体的内容。对于一个 Intent 对象，消息“目的地”是必须的，而内容则是可选项。</p><p>在上面的实例中通过 Activity. startActivity(intent)启动另外一个 Activity 的时候，我们在 Intent 类的构造器中指定了“收件人地址”。</p><p>如果我们想要给“收件人”Activity 说点什么的话，那么可以通过下面这封“e-mail”来将我们消息传递出去：</p><pre><code>Intent intent =new Intent(CurrentActivity.this,OtherActivity.class); // 创建一个带“收件人地址”的 email Bundle bundle =new Bundle();// 创建 email 内容bundle.putBoolean(&quot;boolean_key&quot;, true);// 编写内容bundle.putString(&quot;string_key&quot;, &quot;string_value&quot;); intent.putExtra(&quot;key&quot;, bundle);// 封装 email startActivity(intent);// 启动新的 Activity</code></pre><p>那么“收件人”该如何收信呢？在 OtherActivity类的 onCreate()或者其它任何地方使用下面的代码就可以打开这封“e-mail”阅读其中的信息：</p><pre><code>Intent intent =getIntent();// 收取 email Bundle bundle =intent.getBundleExtra(&quot;key&quot;);// 打开 email bundle.getBoolean(&quot;boolean_key&quot;);// 读取内容bundle.getString(&quot;string_key&quot;);</code></pre><p>上面我们通过 bundle对象来传递信息，bundle维护了一个 HashMap&lt;String, Object&gt;对象，将我们的数据存贮在这个 HashMap 中来进行传递。但是像上面这样的代码稍显复杂，因为 Intent 内部为我们准备好了一个 bundle，所以我们也可以使用这种更为简便的方法：</p><pre><code>Intent intent =new Intent(EX06.this,OtherActivity.class);  intent.putExtra(&quot;boolean_key&quot;, true);  intent.putExtra(&quot;string_key&quot;, &quot;string_value&quot;);  startActivity(intent);</code></pre><p>接收：</p><pre><code>Intent intent=getIntent();  intent.getBooleanExtra(&quot;boolean_key&quot;,false);  intent.getStringExtra(&quot;string_key&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-正常的周期&quot;&gt;&lt;a href=&quot;#1-正常的周期&quot; class=&quot;headerlink&quot; title=&quot;1.正常的周期&quot;&gt;&lt;/a&gt;1.正常的周期&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;OnCreate: 生命周期的第一个方法，可以
      
    
    </summary>
    
      <category term="Android" scheme="https://zengwei123.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="https://zengwei123.github.io/2016/09/04/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zengwei123.github.io/2016/09/04/hexo常用命令/</id>
    <published>2016-09-04T08:25:04.000Z</published>
    <updated>2018-08-06T02:57:06.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog"><a href="#1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog" class="headerlink" title="1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog"></a>1.新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址,[folder]可以随意命名，如：blog</h4><blockquote><p>$ hexo init [folder]   </p></blockquote><p><br><br></p><h4 id="2-创建一篇文章，-layout-为博客文章布局，可以设置为下面三种布局之一-title-随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致"><a href="#2-创建一篇文章，-layout-为博客文章布局，可以设置为下面三种布局之一-title-随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致" class="headerlink" title="2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致"></a>2.创建一篇文章，[layout]为博客文章布局，可以设置为下面三种布局之一 title 随意取名，会作为你的文章的文件的名字，同时也会作为文章标题，可以在里面修改，不一定要一致</h4><ul><li><h5 id="·-post-nbsp-nbsp-我一般都用post，默认就是这个"><a href="#·-post-nbsp-nbsp-我一般都用post，默认就是这个" class="headerlink" title="· post&nbsp;&nbsp;我一般都用post，默认就是这个"></a>· post&nbsp;&nbsp;我一般都用post，默认就是这个</h5></li><li><h5 id="·-page"><a href="#·-page" class="headerlink" title="· page"></a>· page</h5></li><li><h5 id="·-draft"><a href="#·-draft" class="headerlink" title="· draft"></a>· draft</h5></li></ul><blockquote><p>$ hexo new [layout] <title></title></p></blockquote><hr><p>文章建立之后，在你的网站文件夹中<span style="color:#ff0000"> <strong>\source\_posts</strong> </span> 路径下面可以找到创建的文章文件，是 <strong>markdown</strong> 格式的，文件后缀名为 <strong>.md</strong>, <strong>Front-matter</strong> 是文件最上方以 — 分隔的区域，用于指定个别文件的变量,以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><ul><li><strong>·</strong> layout 布局</li><li><strong>·</strong> title 标题</li><li><strong>·</strong> date 建立日期</li><li><strong>·</strong> updated 更新日期</li><li><strong>·</strong> comments 开启文章的评论功能</li><li><strong>·</strong> tags 标签</li><li><strong>·</strong> categories 分类</li><li><strong>·</strong> permalink 覆盖文章网址<br><br><br><h4 id="3-将更改上传到github-每次更新完博客输入这条命令，就能将文章跟新到博客了"><a href="#3-将更改上传到github-每次更新完博客输入这条命令，就能将文章跟新到博客了" class="headerlink" title="3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了"></a>3. 将更改上传到github,每次更新完博客输入这条命令，就能将文章跟新到博客了</h4><blockquote><p>$ hexo g -d</p></blockquote></li></ul><p><br><br></p><h4 id="4-启动本地服务-可以在写完文章后查看效果"><a href="#4-启动本地服务-可以在写完文章后查看效果" class="headerlink" title="4.启动本地服务,可以在写完文章后查看效果"></a>4.启动本地服务,可以在写完文章后查看效果</h4><blockquote><p>$ hexo s</p></blockquote><p><br><br></p><h4 id="5-有时候博客写完，上传giehub无效果，那么试试清除缓存"><a href="#5-有时候博客写完，上传giehub无效果，那么试试清除缓存" class="headerlink" title="5.有时候博客写完，上传giehub无效果，那么试试清除缓存"></a>5.有时候博客写完，上传giehub无效果，那么试试清除缓存</h4><blockquote><p>$ hexo clean</p></blockquote><p><br><br><br>基本的hexo编写博客的使用就到这里了，使用上面几条命令就能够创建编写上传你的文章到博客去。其他的一些操作可以去hexo官网查看官方文档<br><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">HEXO官方文档</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地址-folder-可以随意命名，如：blog&quot;&gt;&lt;a href=&quot;#1-新建一个网站，如果没有指定路径的文件夹，那么将会在默认路径下面建立网站，在建立的时候可以看到地
      
    
    </summary>
    
      <category term="Hexo" scheme="https://zengwei123.github.io/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客</title>
    <link href="https://zengwei123.github.io/2016/09/02/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zengwei123.github.io/2016/09/02/hexo搭建博客/</id>
    <published>2016-09-02T15:15:04.000Z</published>
    <updated>2018-08-06T07:16:01.561Z</updated>
    
    <content type="html"><![CDATA[<p>花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！</p><p>   Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致配置不一样，我是windows所有</p><blockquote><h4 id="1-安装git与node-js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的"><a href="#1-安装git与node-js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的" class="headerlink" title="1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的"></a>1.安装git与node.js，这两个环境为搭建博客的基础，如果没有的话是搭建不了的</h4></blockquote><p>安装git、node.js，首先官网去下载安装包，如果是mac一行命令的事情，然后一直下一步下一步下一步就ok,没有什么其他的出问题百度吧，这里就不多说了，下面贴上两个东西的下载地址<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下找地址</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js下找地址</a></p><blockquote><h4 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h4></blockquote><p>安装好Git后，桌面右击会增加两个东西 <strong><em>Git GUI here</em></strong> 、<strong><em>Git Bash here</em></strong> 这两个东西，点击Bash,就进入了Git的终端命令的界面了，你就可以快乐的敲命令了，输入 </p><p><span style="color:red"><strong>npm install -g hexo-cli</strong><br></span></p><p>刷刷刷，然后Hexo就安装好了，你就可以搭建你的博客了</p><blockquote><h4 id="3-建站"><a href="#3-建站" class="headerlink" title="3.建站"></a>3.建站</h4></blockquote><p>首先先创建你的网站，在git命令终端用下面这个命令</p><p></p><p><span style="color:red"><strong>hexo init folder</strong></span></p><p>folder可以自己随意命名，也可以随意指定路径，然后等待一会就把网站给你创建好了，在创建的命令信息中你可以看到自己创建的网站路径，记住这个路径，然后你可以输入</p><p><span style="color:red"><strong>hexo s</strong></span></p><p>这个命令启动服务来本地运行网站，浏览器输入：127.0.0.1:4000 就能够看到Hexo默认的主题我网站，这样我们就已经建好站了</p><blockquote><h4 id="4-配置到Github"><a href="#4-配置到Github" class="headerlink" title="4.配置到Github"></a>4.配置到Github</h4></blockquote><p>首先在github上面创建一个仓库名字叫做：用户名.github.io,注意用户名一定要跟自己的github账户相同<center><img src="/2016/09/02/hexo搭建博客/s.jpg"></center><br>创建仓库<br><center><img src="/2016/09/02/hexo搭建博客/2.jpg"></center><br><br>创建好仓库之后拿到他的ssh地址或者Https地址<br><center><img src="/2016/09/02/hexo搭建博客/3.jpg"></center><br><br>这样我们就吧hexo对应的github仓库建立好了，然后来到博客根路径下，打开_config.yml这个文件夹<br>找到下面这一段，将repository的内容替换成你自己刚刚拿到的ssh或HTTPs地址<br><center><img src="/2016/09/02/hexo搭建博客/4.png"></center><br>然后在再到下面这段，将里面的url换成你自己的：用户名.github.io(注意：这个url就是你以后博客的地址)<br><br><center><img src="/2016/09/02/hexo搭建博客/6.png"></center><br><br>到这里我们基本上就跟github关联起来了，但是为了以后更加方便，我们配置一下SSH</p><blockquote><h4 id="5-配置SSH"><a href="#5-配置SSH" class="headerlink" title="5.配置SSH"></a>5.配置SSH</h4></blockquote><p>首先，终端中输入cd ~/.ssh 查看有没有SSH如果有就删除吧，然后输入ssh-keygen -t rsa -C “你的邮箱”<br>，后面会要你输入密码，这个不用管，一直回车，最后如果出现下面这个图的样子，就是成功了<br><center><img src="/2016/09/02/hexo搭建博客/7.png"></center><br><br>然后到类似于：C:\Users\13085.ssh这种的目录下找到一个叫id_rsa.pub的文件，打开将里面的东西全部复制，进入GitHub<br><center><img src="/2016/09/02/hexo搭建博客/8.png"></center><br><br><center><img src="/2016/09/02/hexo搭建博客/9.png"></center><br><br>到这里，SSH就全部配置完了</p><blockquote><h4 id="6-上传网站"><a href="#6-上传网站" class="headerlink" title="6.上传网站"></a>6.上传网站</h4></blockquote><p>输入命令hexo g，此时若出现如下报错：<br>ERROR Local hexo not found in ~/blog<br>ERROR Try runing: ‘npm install hexo –save’<br>则执行命令：<br><span style="color:red"><strong>npm install hexo –save</strong></span><br>若无报错，自行忽略此步骤。</p><p>然后输入hexo d,若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：<br><span style="color:red"><strong>npm install hexo-deployer-git –save</strong></span></p><blockquote><h4 id="7-查看网站"><a href="#7-查看网站" class="headerlink" title="7.查看网站"></a>7.查看网站</h4></blockquote><p> 打开浏览器输入：https://你的用户名.github.io，就能够看到你的网站了，跟前面本地看到的效果是一样的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;花了个半天时间把个博客搭建好了，不容易，第一篇博客就写怎么拿Hexo搭建博客吧！&lt;/p&gt;
&lt;p&gt;   Hexo是建立在Git和Node.js的基础上的，所以在搭建博客的时候需要有这两个环境，MAC跟Windows搭建都一样，都是在git下面所以不会存在什么因为系统的原因导致
      
    
    </summary>
    
      <category term="Hexo" scheme="https://zengwei123.github.io/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
